<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rxjava | My little software store]]></title>
  <link href="http://fedepaol.github.io/blog/categories/rxjava/atom.xml" rel="self"/>
  <link href="http://fedepaol.github.io/"/>
  <updated>2018-10-31T07:11:21+01:00</updated>
  <id>http://fedepaol.github.io/</id>
  <author>
    <name><![CDATA[Federico Paolinelli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android, Okhttp and Websockets]]></title>
    <link href="http://fedepaol.github.io/blog/2017/04/30/android-okhttp-and-websockets/"/>
    <updated>2017-04-30T23:04:19+02:00</updated>
    <id>http://fedepaol.github.io/blog/2017/04/30/android-okhttp-and-websockets</id>
    <content type="html"><![CDATA[<h2>Websockets</h2>

<p>Rest http calls are the most common interaction between Android apps and remote servers. However, there are some scenarios where the interaction is better handled via a persistent connection: think about a chat, or a multiplayer game where data flows in both directions and the server needs to push data to the clients and to be aware of which client are connected.</p>

<p>This kind of scenario can be implemented through Websockets.</p>

<h3>OkHttp and Websockets</h3>

<p>Given the quality of the libraries offered by Square, OkHttp was the first library I checked when I recently had to deal with websockets. Luckily, <a href="https://medium.com/square-corner-blog/web-sockets-now-shipping-in-okhttp-3-5-463a9eec82d1">WebSocket support was introduced in December, 2016</a>. In this post I will try to describe how to use it, and to show how it is different from using it with regular http calls.</p>

<h3>Establishing the connection</h3>

<p>Establishing the connection is pretty straightforward. You declare the OkHttp client as always:</p>

<pre><code class="java">
    client = new OkHttpClient.Builder()
                .readTimeout(3,  TimeUnit.SECONDS)
                .build();
</code></pre>

<p>and then take a websocket object out of it:</p>

<pre><code class="java">    Request request = new Request.Builder()
                .url(serverUrl)
                .build();
        webSocket = client.newWebSocket(request, new WebSocketListener() {
                            ...
                        });
</code></pre>

<p>Please note that by creating the websocket, OkHttp will try to establish the connection with the server. The second parameter of the <code>newWebSocket</code> factory method needs to implement the <code>WebSocketListener</code> interface, in order to get asynchronously notified of the various events occurred to the socket (such as an incoming message, or the disconnection of the socket, or a failure).</p>

<h3>Sending a message</h3>

<p>Sending a message is easy. Just call <code>send</code> with a <em>String</em> or a <em>ByteString</em> as an argument. Since OkHttp will send the data using its own background thread, <code>send</code> can be called from any thread without worrying of blocking the current thread (and risking to get a NetworkOnMainThreadException).</p>

<p>The only caveat here is that a positive result only indicates that the message was enqueued, but it does not reflect the result of the trasmission. From my understanding, the user of the library is notified only in case of failure via the <code>onFailure</code> callback, so an optimistic approach must be taken in place.</p>

<h3>The callbacks</h3>

<p>The <a href="https://github.com/square/okhttp/blob/master/okhttp/src/main/java/okhttp3/WebSocketListener.java">WebSocketListener</a> interface provides callbacks to handle the asynchronous events related to the socket. Those includes the fact that the socket was opened (or closed), or that a new message was received.</p>

<p>Unlike the trasmission of the data, the interaction between the callbacks and the main Android thread needs to be implemented carefully, since <code>WebSocketListener</code>&rsquo;s method will be executed inside a background thread. Using a <code>handler</code> is the &ldquo;vanilla Android&rdquo; approach to let a background thread interact with a thread associated to a looper (such as Android&rsquo;s main thread).</p>

<pre><code class="java">    @Override
    public void onMessage(WebSocket webSocket, String text) {
    ...
        handler.sendMessage(..);
    }
</code></pre>

<p>Another way to achieve the same result would be to go reactive and expose observables to publish this events.</p>

<h3>Closing the connection</h3>

<p>OkHttp provides two methods to close the connection:</p>

<h2>Close</h2>

<p><code>webSocket.close(0, "Bye");</code> asks the server to gracefully close the connection and waits for confirmation.
All the queued messages are trasmitted <strong>before</strong> closing the connection.</p>

<p>Since some interaction is involved, the socket might not be immediately closed. If the initialization and the closure of the connection are bound to the lifecycle of the activity (i.e. in onPause / onResume), what could happen is that some messages are received <strong>after</strong> close was invoked, so this needs to be handled carefully.</p>

<h2>Cancel</h2>

<p>Cancel is more brutal: it just discards all the queued messages and brutally closes the socket. This has the advantage of not having to wait for the housekeeping and the trasmission of enqueued messages. However, choosing <code>cancel</code> over <code>close</code> really depends on the use case.</p>

<h1>Talk is cheap, show me the code</h1>

<p><a href="https://github.com/fedepaol/websocket-sample">Here</a> I pushed a simple example that allows an app to open the websocket when the app goes in foreground and shuts the websocket down when the app goes on background. This is the suggested approach for persistent connections. Using a service to hold the persisten connection is considered a misbehaviour and doze mode will make your app&rsquo;s life really hard.</p>

<p>The example has some weak point that could be improved:</p>

<h4>Cancel is invoked when the app goes in background.</h4>

<p>This means that some messages could eventually get discarded. A better approach would be to invoke close and wait the connection to be gracefully closed and all the messages sent. Since in <code>onPause</code> the activity disposes the subscriptions, no leaking is happening. We can just hope that the application process will live long enough to let OkHttp thread to do what it needs to do in order to gracefully close the connection. A more complex approach could involve a Service or using the JobScheduler.</p>

<h4>No failure of trasmission is taken into account</h4>

<p>onFailure should listen for failures and notify the user of the failure (or even retry to send failed messages) while in the sample it just forces the disconnection.</p>

<h4>No RxJava!</h4>

<p>I wanted to keep the app simple and to avoid to introduce extra complexity, but handlers are so 2013. A better solution would have used RxJava (and probably there are many cool libraries that support that out of the box). Using RxJava would make super easy to use and transform the incoming messages and / or implement smart reconnection policies such as exponential backoff.</p>

<h1>Conclusion</h1>

<p>Using websockets is a completely different beast from getting / posting to http endpoints where you fetch (or post) and forget about the call, however the OkHttp implementation is really easy to use.</p>

<p>On your side, you&rsquo;ll have not only to handle the trasmission / reception of the messages, but you will also need to monitor the state of the connection and behave accordingly.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Subscribe It While It's Hot: Cached Rest Requests With RxJava]]></title>
    <link href="http://fedepaol.github.io/blog/2016/01/01/cached-rest-requests-with-rxjava/"/>
    <updated>2016-01-01T17:54:21+01:00</updated>
    <id>http://fedepaol.github.io/blog/2016/01/01/cached-rest-requests-with-rxjava</id>
    <content type="html"><![CDATA[<h4>Disclaimer:</h4>

<p>In this post I am trying to cover a proper approach to a common problem. I am still in the process of wrapping my head around RxJava so what I write here might not be the best way to solve the problem.</p>

<h1>Cached requests with RxJava</h1>

<p>Lately I&rsquo;ve been trying to develop a rest backed app using RxJava. I must admit that once you get in the proper mental mood, RxJava almost feels like cheating. Everything looks cleaner, multiple requests can be composed and manipulated easily, the StrictMode gets satisfied by observing on the ui thread and subscribing on a different thread, and all the nice things that can be read about how cool is RxJava with Android.
What I could not find easily, was how to store the result of a request and be sure that even in case of no network, a cached content was available for the user, while still handling everything in a reactive fashion.</p>

<h3>Caching vs non caching</h3>

<p>Going straight from rest result to the UI is appropriate in many cases, for example when displaying the result of a search whose arguments are not predictable (think about Ebay, or Amazon where the user is looking for something different every time).</p>

<p><em>However</em>, there are cases when the results fetched earlier are still significant and displaying them can improve the user experience significantly, compared to a spinning wheel or a white page. Those cases include your twitter feed, a local weather forecast that was fetched just 5 minutes before, or the list of the github repos of a given user.</p>

<p>Here you can see the difference between a non cached version and a cached version of the same activity:</p>

<p><img src="/images/uncached.gif" width="300">      <img src="/images/cached.gif" width="300"></p>

<p>For this reason I tried to figure out what could have been a clean way to cache the results of a request while keeping the flow in a reactive fashion.</p>

<h3>The storage as the unique source of the truth</h3>

<h4>All reactive</h4>

<p>If we want to cache the data while keeping everything inside the same subscription, things get a bit messy. The result of the request is thrown at the UI and the response is also stored in the storage. The UI subscribes from the storage too but checks which result came first and if the data is too old.</p>

<p><img src="/images/messy.jpg" width="500"></p>

<h4>Cached</h4>

<p>In this <em>hybrid</em> variant, the UI subscribes only to the storage, and a facade class wraps the storage and the subscription to the retrofit client that feeds the storage. Once the storage is filled with new data, the UI thread is automatically notified of every change.
<img src="/images/clean.jpg" width="500"></p>

<p>In this scenario the observable acts as a <em>hot</em> observable, the first time it gets subscribed it emits the content of the storage, and any other change it might happen to it.</p>

<h3>Talk is cheap, show me the code</h3>

<p>A working example of the following code can be found <a href="https://github.com/fedepaol/RxRestSample">in my github repo here</a>
To write this sample, I started from the abused Github apis which seems to power the 99% of the rest related examples. Sorry about that.</p>

<p>First there is the storage. I wrapped a SQLite helper (which I happily generated with <a href="https://github.com/fedepaol/Android-sql-lite-helper">my handy script</a>) with a class that contains a <a href="http://reactivex.io/RxJava/javadoc/rx/subjects/PublishSubject.html">PublishSubject</a> which can be subscribed to and which we will notify when the insertion methods are called:</p>

<pre><code class="Java">public class ObservableRepoDb {
    private PublishSubject&lt;List&lt;Repo&gt;&gt; mSubject = PublishSubject.create();
    private RepoDbHelper mDbHelper;

    private List&lt;Repo&gt; getAllReposFromDb() {
        List&lt;Repo&gt; repos = new ArrayList&lt;&gt;();
        // .. performs the query and fills the result
        return repos;
    }

    public Observable&lt;List&lt;Repo&gt;&gt; getObservable() {
        Observable&lt;List&lt;Repo&gt;&gt; firstTimeObservable =
                Observable.fromCallable(this::getAllReposFromDb);

        return firstTimeObservable.concatWith(mSubject);
    }

    public void insertRepo(Repo r) {
        // ...
        // performs the insertion on the SQLite helper
        // ...
        List&lt;Repo&gt; result = getAllReposFromDb();
        mSubject.onNext(result);
    }
}
</code></pre>

<p>What we have here is the first piece of the puzzle: a storage that can be subscribed to. The concatenation is needed because we want it to emit the content of the storage as soon as it gets subscribed.</p>

<p>Then there is the facade class, where we get the observable from and to which we start a new update:</p>

<pre><code class="Java">public class ObservableGithubRepos {
    ObservableRepoDb mDatabase;
    private BehaviorSubject&lt;String&gt; mRestSubject;

    // ...
    public Observable&lt;List&lt;Repo&gt;&gt; getDbObservable() {
        return mDatabase.getObservable();
    }

    public void updateRepo(String userName) {
        Observable&lt;List&lt;Repo&gt;&gt; observable = mClient.getRepos(userName);
        observable.subscribeOn(Schedulers.io())
                  .observeOn(Schedulers.io())
                  .subscribe(l -&gt; mDatabase.insertRepoList(l));
    }
} 
</code></pre>

<p>Note that everything happens far from the UI thread. This is because we are going to subscribe to the database observable as the unique source of truth.</p>

<p>Now, given that the observable is now <em>hot</em>, we can&rsquo;t listen for its <em>onComplete</em> in order to stop any progress indicators we might put in place.
What we need is another subject that can be bound to the update request, so here it is the new facade class:</p>

<pre><code class="Java ">public class ObservableGithubRepos {
    // ...

    public Observable&lt;List&lt;Repo&gt;&gt; getDbObservable() {
        return mDatabase.getObservable();
    }

    public Observable&lt;String&gt; updateRepo(String userName) {
        BehaviorSubject&lt;String&gt; requestSubject = BehaviorSubject.create();

        Observable&lt;List&lt;Repo&gt;&gt; observable = mClient.getRepos(userName);
        observable.subscribeOn(Schedulers.io())
                  .observeOn(Schedulers.io())
                  .subscribe(l -&gt; {
                                    mDatabase.insertRepoList(l);
                                    requestSubject.onNext(userName);},
                             e -&gt; requestSubject.onError(e),
                             () -&gt; requestSubject.onCompleted());
        return requestSubject;
    }
}
</code></pre>

<p>In the UI client (activity or fragment) we&rsquo;ll need to subscribe to the storage in order to get the data and to the request observable in order to stop the progress indicators. An observable that emits the state of the pending request is returned every time an update is being requested.</p>

<pre><code class="Java">    mObservable = mRepo.getDbObservable();
    mProgressObservable = mRepo.getProgressObservable()

    mObservable.subscribeOn(Schedulers.io())
                   .observeOn(AndroidSchedulers.mainThread()).subscribe(l -&gt; {
                    mAdapter.updateData(l);
                });

    Observable&lt;List&lt;Repo&gt;&gt; progressObservable = mRepo.updateRepo("fedepaol");
    progressObservable.subscribeOn(Schedulers.io())
                           .observeOn(AndroidSchedulers.mainThread())
                           .subscribe(s -&gt; {},
                                      e -&gt; { Log.d("RX", "There has been an error");
                                            mSwipeLayout.setRefreshing(false);
                                      },
                                      () -&gt; mSwipeLayout.setRefreshing(false));
</code></pre>

<p>Please remember that the DbObservable is a hot one, so every time a call to updateRepo happens, the db will be fed with the result of the query and the ui will get subsequently notified.</p>

<h3>SqlBrite</h3>

<p>If all this wrapping seems too laboruous, the prolific guys from Square wrote <a href="https://github.com/square/sqlbrite">SqlBrite</a> which is a super generic database wrapper that was written for this same purpouse. I am sure it&rsquo;s better and more battle field tested than the poor man&rsquo;s version we can write by ourselves.</p>

<h2>Conclusion</h2>

<p>I don&rsquo;t know if this is an healthy way to use RxJava. Maybe I ended up with this scenario only because I am not 100% confident with RxJava and I am putting some non rx-ness in the middle to better control it.
Here we need to choose where to place the operators, since we can modify the flow that feeds the storage from the http client, or the flow that comes out of the storage itself.</p>

<p>In any case, having an unique source of truth seems more clear, and I feel that in this way it would be a lot easier to do stuff like prefetching, scheduling updates so the user is presented with fresh data (remember having your <a href="https://www.youtube.com/watch?v=GcNNx2zdXN4">app work like magic?</a>), checking if an update is worth to be done at all (such as displaying a 5 minutes old weather forecast) and stuff like that.</p>

<p>Thanks to Fabio Collini for spotting a lot of mistakes in the first draft of this posts, and to Riccardo Ciovati for proof reading it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unit Testing RxJava Observables and Subscriptions]]></title>
    <link href="http://fedepaol.github.io/blog/2015/09/13/testing-rxjava-observables-subscriptions/"/>
    <updated>2015-09-13T21:26:15+02:00</updated>
    <id>http://fedepaol.github.io/blog/2015/09/13/testing-rxjava-observables-subscriptions</id>
    <content type="html"><![CDATA[<h2>Testing RxJava</h2>

<p>While catching up with the latest Android novelties I could not ignore RxJava, which seems to grow in popularity between android developers.</p>

<p>If you just heard about it, and you want to get your feet wet, I really recommend Dan Lew&rsquo;s <a href="http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/">Grokking with RxJava</a> series as a starting point.</p>

<p><strong>RxJava is asynchronous by nature</strong>, so unit testing it might seem a daunting at first, especially if you use that asynchronous interaction to test stuff. Luckily, RxJava (and RxAndroid) come with a couple of tools that will make our life a lot easier.</p>

<h2>What to (unit) test</h2>

<p>There are at least a couple of things you&rsquo;ll want to test:</p>

<ol>
<li>You will want to test the <strong>observables</strong>, meaning not only the observables you built, but also the resulting composition of the various operators you may want to apply to them.</li>
<li>Given a certain observable (or its mock), you will want to test <strong>how the rest of your application behaves while triggered by the subscription</strong>.</li>
</ol>


<h2>Testing the observables</h2>

<p>Despite the fact that a subscription is asynchronous, there are (at least) a couple of ways to make the stream of your observable synchronous.</p>

<p>The first way is by using
<code>Java
ResultToCheck res = myObservable.toBlocking().first();
</code></p>

<p>This works because <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toBlocking%28%29">toBlocking</a> converts the observable to a blocking one, while <a href="http://reactivex.io/documentation/operators/first.html">first</a> returns the first emitted element.
The calling code will wait synchronously until the observer calls onCompleted().</p>

<p><strong>The official way to test an observable</strong> is by using a <a href="http://reactivex.io/RxJava/javadoc/rx/observers/TestSubscriber.html">TestSubscriber</a>, an helper subscriber provided directly by the RxJava library.
As with toBlocking, a test subscription is synchronous.
Here you can find an example:</p>

<pre><code class="Java">Observable&lt;RubberChicken&gt; obs = obsFactory.getObservable();
TestSubscriber&lt;RubberChicken&gt; testSubscriber = new TestSubscriber&lt;&gt;();
obs.subscribe(testSubscriber);

testSubscriber.assertNoErrors();
List&lt;RubberChicken&gt; chickens = testSubscriber.getOnNextEvents();
// Assert your chickens integrity here
</code></pre>

<p><code>TestSubscriber</code> comes with a bunch of helper methods for testing, like specific assertions and other stuff. On top of that, its <code>getOnNextEvents()</code> method is blocking and  will return all the emitted items as elements of a list.
This is a neat way to test not only your observers, but also to check if the compositions you put in place are working as expected. That makes testing observables super easy.</p>

<h2>Testing the subscription</h2>

<p>Once your observables are in place, you will likely to be observing them on some thread, and subscribing them on some other thread. This will make it harder for us to test how our activity (or fragment) reacts to a triggered subscription.</p>

<p>RxJava (and RxAndroid) provide a way to override the schedulers exposed when <code>Schedulers.io()</code> or <code>AndroidSchedulers.mainThread()</code> are called. By replacing them with <code>Schedulers.immediate()</code>, your code will run immediately and you&rsquo;ll be able to see its results.</p>

<p>The solution is a bit hacky, since we need to call <code>reset()</code> method before overriding RxJava&rsquo;s schedulers, which is package protected. I <em>took inspiration</em> from Alexis Mas&#8217; <a href="http://alexismas.com/blog/2015/05/20/unit-testing-rxjava/">blogpost</a> extending RxJavaPlugins class (there no need for that with RxAndroid):
&#8220;`Java
package rx.plugins;</p>

<p>public class RxJavaTestPlugins extends RxJavaPlugins {
    RxJavaTestPlugins() {
        super();
    }</p>

<pre><code>public static void resetPlugins(){
    getInstance().reset();
}
</code></pre>

<p>}</p>

<pre><code>
Registering a scheduler hook that provides a custom implemetation (Schedulers.immediate()) will end up in overriding the schedulers we are using.

As pointed out by [Patrik Åkerfeldt](https://twitter.com/pakerfeldt) in the comments, since the hooks are asked to provide a scheduler implementation during the initialization of the Schedulers class, we have only one chance to override the default schedulers. For this reason, there is no point in setting them up in the `setup` phases of all our tests.

The best place to override them once seems to be the `TestRunner`'s constructor. 

The custom `TestRunner` will look like this:
</code></pre>

<p>public class RxJavaTestRunner extends RobolectricGradleTestRunner {
    public RxJavaTestRunner(Class&lt;?> testClass) throws InitializationError {
        super(testClass);</p>

<pre><code>    RxJavaTestPlugins.resetPlugins();
    RxJavaPlugins.getInstance().registerSchedulersHook(new RxJavaSchedulersHook() {
        @Override
        public Scheduler getIOScheduler() {
            return Schedulers.immediate();
        }
    });
}
</code></pre>

<p>}
&#8220;`</p>

<p>And this is how the <code>setup()</code> and <code>teardown()</code> methods will look like (here I am using robolectric but it makes no difference with AndroidTests):</p>

<pre><code class="Java">@RunWith(RxJavaTestRunner.class)
@Config(constants = BuildConfig.class,
application = TestRobolectricApplication.class)
public class SubscriberTest {
    @Before
    public void setup() {
        RxAndroidPlugins.getInstance().registerSchedulersHook(new RxAndroidSchedulersHook() {
            @Override
            public Scheduler getMainThreadScheduler() {
                return Schedulers.immediate();
            }
        });
    }

    @After
    public void tearDown() {
        RxAndroidPlugins.getInstance().reset();
    }}

    /* Your tests here */
}
</code></pre>

<p>As I already mentioned, you can inject the custom schedulers only once per test session. On the other hand, RxAndroidPlugins come with a reset method that will allow us to hook in different schedulers in different threads.</p>

<p>This, together with a non blocking observable (for instance by replacing your long taking observable with a mocked <code>Observable.just()</code>) will make our test synchronous.</p>

<p>In order to inject a mocked observable, we can override the Application object used by Robolectric,  as described in my <a href="http://fedepaol.github.io/blog/2015/09/05/mocking-with-robolectric-and-dagger-2/">previous post here</a> .</p>

<h2>Bonus point: debugging</h2>

<p>If the unit tests are not enough, and you want to check what is happening inside the chaining / transformation of the stream, you can set an <code>ObservableExecutionHook</code> that will be triggered when observables are being called:</p>

<pre><code class="Java">   private void enableRxTrack() {
        RxJavaPlugins.getInstance().registerObservableExecutionHook(new DebugHook(new DebugNotificationListener() {
            final String TAG = "RXDEBUG";
            public Object onNext(DebugNotification n) {
                Log.v(TAG, "onNext on " + n);
                return super.onNext(n);
            }


            public Object start(DebugNotification n) {
                Log.v(TAG,"start on "+n);
                return super.start(n);
            }


            public void complete(Object context) {
                super.complete(context);
                Log.v(TAG,"oncomplete n "+context);
            }

            public void error(Object context, Throwable e) {
                super.error(context, e);
                Log.e(TAG,"error on "+context);
            }
        }));
    }
</code></pre>

<h1>TL;DR:</h1>

<ul>
<li>Use TestSubscriber when testing how an observable (or a composition of observables) behaves</li>
<li>Mock your observable and override the default schedulers to test how the subscribing class works</li>
<li>Enable the tracking of your observables by registering an observable execution hook</li>
</ul>


<p>A working example (rubber chickens included) can be found on my <a href="https://github.com/fedepaol/TestingRxJava">github repo</a>.</p>

<h3>References</h3>

<ul>
<li><a href="https://medium.com/ribot-labs/unit-testing-rxjava-6e9540d4a329">Unit testing rxjava (observables)</a> by Iván Carballo</li>
<li><a href="http://alexismas.com/blog/2015/05/20/unit-testing-rxjava/">Unit testing rxjava (subscription)</a> by Alexis Mas</li>
<li><a href="http://fragmentedpodcast.com/episodes/3/">This</a> and <a href="http://fragmentedpodcast.com/episodes/4/">this</a> episodes of <a href="http://fragmentedpodcast.com">Fragmented Podcast</a> where Dan Lew gave some insights about RxJava, where I heard about the scheduler overriding trick</li>
<li>Patrik Åkerfeldt&rsquo;s example that demonstrates how the scheduler injection works only before Scheduler class initialization</li>
</ul>

]]></content>
  </entry>
  
</feed>
