<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Testing | My little software store]]></title>
  <link href="http://fedepaol.github.io/blog/categories/testing/atom.xml" rel="self"/>
  <link href="http://fedepaol.github.io/"/>
  <updated>2018-10-26T20:45:18+02:00</updated>
  <id>http://fedepaol.github.io/</id>
  <author>
    <name><![CDATA[Federico Paolinelli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android, MVP, Dagger and Testing]]></title>
    <link href="http://fedepaol.github.io/blog/2016/08/27/android-mvp-testing/"/>
    <updated>2016-08-27T22:52:07+02:00</updated>
    <id>http://fedepaol.github.io/blog/2016/08/27/android-mvp-testing</id>
    <content type="html"><![CDATA[<h3>MVP is Model View Presenter</h3>

<p>.. which is a pattern that is very popular among Android developers nowdays.</p>

<p>I don&rsquo;t intend to write (yet) another guide about MVP in Android, because others have done a better job, for example:</p>

<ul>
<li><a href="http://antonioleiva.com/MVP-android/">Antonio Leiva&rsquo;s introduction to MVP</a></li>
<li><a href="http://hannesdorfmann.com/mosby/MVP/">Hannes Dorfmann&rsquo;s introduction to Mosby</a></li>
<li><a href="http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/">Fernando Cejas&#8217; post on clean architecture</a></li>
</ul>


<p>A lot have been said about MVP (and other similar patterns), like:</p>

<ul>
<li>it isolates the business logic from the UI</li>
<li>it makes faster and easier to unit test the business logic</li>
<li>it avoids having a god Fragment or Activity class that manages everything</li>
<li>it makes it easier to maintain the app</li>
</ul>


<p>However, the first thing you notice while switching into &ldquo;MVP mode&rdquo;, <em>is a great sense of order</em>.</p>

<p>In all the (few) apps I wrote before, I ended up with the well known hodgepodgey fragment or activity that contained both the UI logic and the business logic.</p>

<p>By defining the responsabilities of the view and of the presenter with MVP, you implicitly define the interfaces between those two components (and the model), <strong>and everything fits its place</strong>.</p>

<p>Every touch, drag, and eventyally lifecycle events are just events that are reported back to the presenter, which then chooses what to do with them. This is powerful.</p>

<h2>This post is about my experience with the MVP pattern, Dagger (2) and testing.</h2>

<p>Given the definition of the interface between the view and the presenter, <strong>I ingenuosly expected that testing of both (using unit tests and Espresso tests) would have been super smooth</strong>. As it often happens, the reality is quite different from what one expects and reads from blogs. In this post I will try to sum up all the issues I had during that process and the solutions I tried to put in place.</p>

<p>In order to better illustrate the concepts, I wrote a little example that can be found on my <a href="https://github.com/fedepaol/MVPtesting">github repo</a></p>

<p>The structure of the app is the same one the can be found googling for Dagger / MVP , for example <a href="https://github.com/antoniolg/androidMVP">here</a>.</p>

<p>The only thing I added is a local component / module that I use in order to inject the stuff needed only by that particular set of classes.</p>

<p>This means that in addition to the global Component / Module classes, used to inject stuff like the storage, there will be a <em>local</em> Component / Module used, for example, to inject the presenter into the View.</p>

<h3>The easy part: testing the presenter</h3>

<p>The dependencies are resolved by passing what it needs as constructor parameters:</p>

<pre><code class="java">    @Before
    public void setup() {
        mMockView = mock(MainView.class);
        mMockStorage = mock(KeyValueStorage.class);
        mToTest = new MainPresenterImpl(mMockView, mMockStorage);
    }
</code></pre>

<p>Since no injection magic is involved here, we can just mock the view and all the other stuff the presenter needs and easily write unit tests for a Presenter instance.</p>

<p>Moreover, all the dependencies with external models / sources of data like retrofit can be tested by testing the behaviour of the presenter.</p>

<h3>The &ldquo;I expected it to be easier part&rdquo;: testing the view</h3>

<p>A common approach I heard around is to test the view not against a mock presenter, but against a presenter injected with mocked &ldquo;external components&rdquo;, such as api client and storage.</p>

<p>What I wanted to achieve here on the other hand, is to test the view driving the behaviour of the presenter it interacts with.</p>

<p>With this strong separation of roles, I expected it to be easy to mock the presenter and test the view with Espresso.</p>

<h4>Injecting a mock presenter</h4>

<p>Since the presenter is provided by the local module and injected into the view by Dagger, I had to find a way to override the Module in order to provide the mock presenter that could drive the tests.</p>

<p>By using the common method to inject the view</p>

<pre><code class="java">    DaggerMainComponent.builder()
                .applicationComponent(app.getComponent())
                .mainModule(new MainModule(this))
                .build().inject(this);
</code></pre>

<p>the only way to override the presenter since it is provided by the &ldquo;real&rdquo; MainModule is to use build flavours, as shown in <a href="https://codelabs.developers.google.com/codelabs/android-testing/#0">Android testing codelab</a>.</p>

<p><strong>However, I wanted to take advantage of Dagger 2 injecting a mock presenter.</strong></p>

<h3>The key of replacing a dependency is by overriding the Application object</h3>

<p>By adding a factory method that returns an istance of the module in the Application class</p>

<pre><code class="java">DaggerMainComponent.builder()
                .applicationComponent(app.getComponent())
                .mainModule(app.getMainModule(this))
                .build().inject(this);
</code></pre>

<p>Then we can be use a custom test runner that provides a subclass of that application object declared in the Manifest.</p>

<pre><code class="java">public class EspressoTestRunner extends AndroidJUnitRunner {
    @Override
    public Application newApplication(ClassLoader cl, String className, Context context) throws
            IllegalAccessException, ClassNotFoundException, InstantiationException {
        return super.newApplication(cl, TestMvpApplication.class.getName(), context);
    }
}
</code></pre>

<p>and declare it in our gradle file</p>

<pre><code class="groovy">
android {
    ... 
    defaultConfig {
    ...
        testInstrumentationRunner 'com.whiterabbit.windlocator.EspressoTestRunner'
    ...
    }
}
</code></pre>

<p>The Application object (and its test variant) is the one responsible of providing all the modules, so by subclassing it we can drive what is provided to be injected:</p>

<pre><code class="java">
public class TestMvpApplication extends MvpApplication {
    private MainModule mMainModule;

    // By usint this two method we can drive whatever module we want during the tests
    // (and with that, drive what classes inject)
    @Override
    public MainModule getMainModule(MainView view) {
        return mMainModule;
    }

    public void setMainModule(MainModule m) {
        mMainModule = m;
    }
}
</code></pre>

<p>This is what the setup method would look like:</p>

<pre><code class="java">@Before
public void setUp() throws Exception {
    // a mock module with the mock presenter to be injected..
    MainModule m = mock(MainModule.class);
    mMockPresenter = mock(MainPresenter.class);

    when(m.provideMainView()).thenReturn(mock(MainView.class)); // this is needed to fool dagger
    when(m.provideMainPresenter(any(MainView.class), any(KeyValueStorage.class)))
        .thenReturn(mMockPresenter);

    Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
    TestMvpApplication app
        = (TestMvpApplication) instrumentation.getTargetContext().getApplicationContext();

    // forced to the application object
    app.setMainModule(m);
}
</code></pre>

<p>A mock module is needed to provide a mock presenter. Then the mock module is passed to the application object.
Please note that in order to have Dagger 2 working, the mock module needs to provide a view instance (even a mock one) that will never be used.</p>

<p>Now we can finally write a test method:</p>

<pre><code class="java">    @Test
    public void testButtonClick() {
        activity.launchActivity(new Intent());
        onView(withId(R.id.main_button)).perform(click());
        verify(mMockPresenter).onButtonClicked();
    }
</code></pre>

<p>After all this struggling, we can &ldquo;just test the view&rdquo;, meaning that we do not need to test if the mocked rest end point was called, nor if the storage was asked to write something.
<strong>We just test the view against the presenter interface</strong></p>

<p>One piece is still missing: what if we want to test the behaviour of the view when one of its methods gets called by the presenter? In the example, the view interface offers a method to set the text displayed.</p>

<p>Again, one could naively think that it would be sufficient to call the method with something like</p>

<pre><code class="java">activity.getActivity().showValue("23");
</code></pre>

<p>The truth is, espresso tests run in a thread different from the UI thread. By doing that, it would result in</p>

<pre><code>Only the original thread that created a view hierarchy can touch its views
</code></pre>

<p>One way to overcome this, is to call the methods in the ui thread</p>

<pre><code class="java">activity.getActivity().runOnUiThread(new Runnable() { // fancy using a lambda here?
                                                 @Override
                                                 public void run() {
                                                     activity.getActivity().showValue("23");
                                                 }
                                             });
</code></pre>

<h4>Why I did not use the <code>@UiThreadTest</code> annotation?</h4>

<p>Simply because it would have ended with another exception since startactivity cannot be called directly from the ui thread.</p>

<h3>To sum up</h3>

<ul>
<li>Make the application provide the Module that provides the presenter(s)</li>
<li>Change the testrunner in order to provide a different application</li>
<li>Let the &ldquo;test&rdquo; application provide a mock module that provides a mock presenter</li>
<li>Test!</li>
</ul>


<h2>Conclusion</h2>

<p>The Mvp pattern isolates the view (which needs to be as dumb as it can) from the presenter.
By instrumenting the view with a mocked presenter, you will drain those tests from any kind of logic we expect to be in the presenter. You just test that the interface between the presenter and the view is working as expected.</p>

<p>By doing this, you can focus on testing the business logic inside the presenter with vanilla unit tests. Your tdd loop will definetely be faster.</p>

<p><em>A big thank as always to my proofreaders Fabio Collini &amp; Riccardo Ciovati</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unit Testing RxJava Observables and Subscriptions]]></title>
    <link href="http://fedepaol.github.io/blog/2015/09/13/testing-rxjava-observables-subscriptions/"/>
    <updated>2015-09-13T21:26:15+02:00</updated>
    <id>http://fedepaol.github.io/blog/2015/09/13/testing-rxjava-observables-subscriptions</id>
    <content type="html"><![CDATA[<h2>Testing RxJava</h2>

<p>While catching up with the latest Android novelties I could not ignore RxJava, which seems to grow in popularity between android developers.</p>

<p>If you just heard about it, and you want to get your feet wet, I really recommend Dan Lew&rsquo;s <a href="http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/">Grokking with RxJava</a> series as a starting point.</p>

<p><strong>RxJava is asynchronous by nature</strong>, so unit testing it might seem a daunting at first, especially if you use that asynchronous interaction to test stuff. Luckily, RxJava (and RxAndroid) come with a couple of tools that will make our life a lot easier.</p>

<h2>What to (unit) test</h2>

<p>There are at least a couple of things you&rsquo;ll want to test:</p>

<ol>
<li>You will want to test the <strong>observables</strong>, meaning not only the observables you built, but also the resulting composition of the various operators you may want to apply to them.</li>
<li>Given a certain observable (or its mock), you will want to test <strong>how the rest of your application behaves while triggered by the subscription</strong>.</li>
</ol>


<h2>Testing the observables</h2>

<p>Despite the fact that a subscription is asynchronous, there are (at least) a couple of ways to make the stream of your observable synchronous.</p>

<p>The first way is by using
<code>Java
ResultToCheck res = myObservable.toBlocking().first();
</code></p>

<p>This works because <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#toBlocking%28%29">toBlocking</a> converts the observable to a blocking one, while <a href="http://reactivex.io/documentation/operators/first.html">first</a> returns the first emitted element.
The calling code will wait synchronously until the observer calls onCompleted().</p>

<p><strong>The official way to test an observable</strong> is by using a <a href="http://reactivex.io/RxJava/javadoc/rx/observers/TestSubscriber.html">TestSubscriber</a>, an helper subscriber provided directly by the RxJava library.
As with toBlocking, a test subscription is synchronous.
Here you can find an example:</p>

<pre><code class="Java">Observable&lt;RubberChicken&gt; obs = obsFactory.getObservable();
TestSubscriber&lt;RubberChicken&gt; testSubscriber = new TestSubscriber&lt;&gt;();
obs.subscribe(testSubscriber);

testSubscriber.assertNoErrors();
List&lt;RubberChicken&gt; chickens = testSubscriber.getOnNextEvents();
// Assert your chickens integrity here
</code></pre>

<p><code>TestSubscriber</code> comes with a bunch of helper methods for testing, like specific assertions and other stuff. On top of that, its <code>getOnNextEvents()</code> method is blocking and  will return all the emitted items as elements of a list.
This is a neat way to test not only your observers, but also to check if the compositions you put in place are working as expected. That makes testing observables super easy.</p>

<h2>Testing the subscription</h2>

<p>Once your observables are in place, you will likely to be observing them on some thread, and subscribing them on some other thread. This will make it harder for us to test how our activity (or fragment) reacts to a triggered subscription.</p>

<p>RxJava (and RxAndroid) provide a way to override the schedulers exposed when <code>Schedulers.io()</code> or <code>AndroidSchedulers.mainThread()</code> are called. By replacing them with <code>Schedulers.immediate()</code>, your code will run immediately and you&rsquo;ll be able to see its results.</p>

<p>The solution is a bit hacky, since we need to call <code>reset()</code> method before overriding RxJava&rsquo;s schedulers, which is package protected. I <em>took inspiration</em> from Alexis Mas&#8217; <a href="http://alexismas.com/blog/2015/05/20/unit-testing-rxjava/">blogpost</a> extending RxJavaPlugins class (there no need for that with RxAndroid):
&#8220;`Java
package rx.plugins;</p>

<p>public class RxJavaTestPlugins extends RxJavaPlugins {
    RxJavaTestPlugins() {
        super();
    }</p>

<pre><code>public static void resetPlugins(){
    getInstance().reset();
}
</code></pre>

<p>}</p>

<pre><code>
Registering a scheduler hook that provides a custom implemetation (Schedulers.immediate()) will end up in overriding the schedulers we are using.

As pointed out by [Patrik Åkerfeldt](https://twitter.com/pakerfeldt) in the comments, since the hooks are asked to provide a scheduler implementation during the initialization of the Schedulers class, we have only one chance to override the default schedulers. For this reason, there is no point in setting them up in the `setup` phases of all our tests.

The best place to override them once seems to be the `TestRunner`'s constructor. 

The custom `TestRunner` will look like this:
</code></pre>

<p>public class RxJavaTestRunner extends RobolectricGradleTestRunner {
    public RxJavaTestRunner(Class&lt;?> testClass) throws InitializationError {
        super(testClass);</p>

<pre><code>    RxJavaTestPlugins.resetPlugins();
    RxJavaPlugins.getInstance().registerSchedulersHook(new RxJavaSchedulersHook() {
        @Override
        public Scheduler getIOScheduler() {
            return Schedulers.immediate();
        }
    });
}
</code></pre>

<p>}
&#8220;`</p>

<p>And this is how the <code>setup()</code> and <code>teardown()</code> methods will look like (here I am using robolectric but it makes no difference with AndroidTests):</p>

<pre><code class="Java">@RunWith(RxJavaTestRunner.class)
@Config(constants = BuildConfig.class,
application = TestRobolectricApplication.class)
public class SubscriberTest {
    @Before
    public void setup() {
        RxAndroidPlugins.getInstance().registerSchedulersHook(new RxAndroidSchedulersHook() {
            @Override
            public Scheduler getMainThreadScheduler() {
                return Schedulers.immediate();
            }
        });
    }

    @After
    public void tearDown() {
        RxAndroidPlugins.getInstance().reset();
    }}

    /* Your tests here */
}
</code></pre>

<p>As I already mentioned, you can inject the custom schedulers only once per test session. On the other hand, RxAndroidPlugins come with a reset method that will allow us to hook in different schedulers in different threads.</p>

<p>This, together with a non blocking observable (for instance by replacing your long taking observable with a mocked <code>Observable.just()</code>) will make our test synchronous.</p>

<p>In order to inject a mocked observable, we can override the Application object used by Robolectric,  as described in my <a href="http://fedepaol.github.io/blog/2015/09/05/mocking-with-robolectric-and-dagger-2/">previous post here</a> .</p>

<h2>Bonus point: debugging</h2>

<p>If the unit tests are not enough, and you want to check what is happening inside the chaining / transformation of the stream, you can set an <code>ObservableExecutionHook</code> that will be triggered when observables are being called:</p>

<pre><code class="Java">   private void enableRxTrack() {
        RxJavaPlugins.getInstance().registerObservableExecutionHook(new DebugHook(new DebugNotificationListener() {
            final String TAG = "RXDEBUG";
            public Object onNext(DebugNotification n) {
                Log.v(TAG, "onNext on " + n);
                return super.onNext(n);
            }


            public Object start(DebugNotification n) {
                Log.v(TAG,"start on "+n);
                return super.start(n);
            }


            public void complete(Object context) {
                super.complete(context);
                Log.v(TAG,"oncomplete n "+context);
            }

            public void error(Object context, Throwable e) {
                super.error(context, e);
                Log.e(TAG,"error on "+context);
            }
        }));
    }
</code></pre>

<h1>TL;DR:</h1>

<ul>
<li>Use TestSubscriber when testing how an observable (or a composition of observables) behaves</li>
<li>Mock your observable and override the default schedulers to test how the subscribing class works</li>
<li>Enable the tracking of your observables by registering an observable execution hook</li>
</ul>


<p>A working example (rubber chickens included) can be found on my <a href="https://github.com/fedepaol/TestingRxJava">github repo</a>.</p>

<h3>References</h3>

<ul>
<li><a href="https://medium.com/ribot-labs/unit-testing-rxjava-6e9540d4a329">Unit testing rxjava (observables)</a> by Iván Carballo</li>
<li><a href="http://alexismas.com/blog/2015/05/20/unit-testing-rxjava/">Unit testing rxjava (subscription)</a> by Alexis Mas</li>
<li><a href="http://fragmentedpodcast.com/episodes/3/">This</a> and <a href="http://fragmentedpodcast.com/episodes/4/">this</a> episodes of <a href="http://fragmentedpodcast.com">Fragmented Podcast</a> where Dan Lew gave some insights about RxJava, where I heard about the scheduler overriding trick</li>
<li>Patrik Åkerfeldt&rsquo;s example that demonstrates how the scheduler injection works only before Scheduler class initialization</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mocking With Robolectric and Dagger 2]]></title>
    <link href="http://fedepaol.github.io/blog/2015/09/05/mocking-with-robolectric-and-dagger-2/"/>
    <updated>2015-09-05T08:22:47+02:00</updated>
    <id>http://fedepaol.github.io/blog/2015/09/05/mocking-with-robolectric-and-dagger-2</id>
    <content type="html"><![CDATA[<h2>Why robolectric</h2>

<p>I&rsquo;ve been a fan of robolectric since the old days, since <a href="http://fedepaol.github.io/blog/2012/07/23/intellij-robolectric-and-android/">when Android Studio was not an option and few developers embraced IntelliJ</a>. I left it a bit behind after the introduction of Android Studio, since its support was far from optimal.</p>

<p>Things have changed, and after listening Corey Latislaw advocating its usage during <a href="http://fragmentedpodcast.com/episodes/13/">this fragmented podcast episode</a> I wanted to give it a spin. Even if there is a bit of debate over its usage, mainly because tests are performed against mocked objects instead of the real framework code, it is the fastest lane to your tdd cycle because tests are run on the local jvm instead of being packed in an apk, deployed on a device and run over there.</p>

<h2>Dependency Injection</h2>

<p>One really cool thing about robolectric 3.0 is the fact that you can override the Application object declared in your manifest with a custom one (which can inherit from your application&rsquo;s one).</p>

<p>If you are using dagger (or dagger 2) and you are using the application as the source of dependency injection for your classes, this allow to easily replace your injected objects with mocks. You can even choose which mocks inject in the setup phase of your tests.</p>

<h2>Let&rsquo;s see an example:</h2>

<p>Let&rsquo;s say you have your application class that exposes all the injected objects in a Dagger 2 fashion, and that you are using it to inject classes in your activities:</p>

<pre><code class="java">    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // stuff 
        ((MyApplication) getApplication()).getComponent().inject(this);
    }
</code></pre>

<p>Now, if we can drive the component injected within our tests, the rest of the app would use them and (hopefully) behave in a way we expect, depending on our mocks instead of the real objects.</p>

<p>The dependencies are provided by a module:</p>

<pre><code class="java">@Module
public class ApplicationModule {
    // stuff

    @Provides
    @Singleton
    GitHubClient provideClient() {
        return new GitHubClient(mApp.getApplicationContext());
    }
    // .. Provides other stuff
}
</code></pre>

<p><code>GitHubClient</code> is a Retrofit (2) powered client that helps to retrieve all the repos for a given user.</p>

<p>By using a test only application, we can provide a module from our tests.</p>

<p>Let&rsquo;s see ApplicationModule&rsquo;s mocked alter ego. Note that we can override only the dependencies that we want to mock:</p>

<pre><code class="java">public class MockApplicationModule extends ApplicationModule {
    List&lt;Repo&gt; result;
    // stuff

    @Override
    GitHubClient provideClient() {
        GitHubClient client = mock(GitHubClient.class);
        // mock behaviour
        return client;
    }

    public void setResult(List&lt;Repo&gt; result) {
        this.result = result;
    }
}
</code></pre>

<p>Now that everything is in place, we can use the mocked objects in our tests:</p>

<pre><code class="java">@RunWith(RobolectricGradleTestRunner.class)
@Config(constants = BuildConfig.class,
        application = TestApplication.class)
public class SampleTest {
    @Before
    public void setup() {
        TestApplication app = (TestApplication) RuntimeEnvironment.application;
        // Setting up the mock module
        MockApplicationModule module = new MockApplicationModule(app);
        module.setResult(mockedResult);
        app.setApplicationModule(module);
    }
}
</code></pre>

<p>From now on, the our tested activities will be injected with our mocked github client and we will be able to test their behaviour.</p>

<h2>Quirks</h2>

<p>Since the Test Application object is created before running the tests, a default application module must be provided, otherwise you&rsquo;ll get a dreaded NPE while running your tests.</p>

<pre><code class="java">public class TestApplication extends MyApplication {
    @Override
    ApplicationModule getApplicationModule() {
        if (mApplicationModule == null) {
            return super.getApplicationModule();
        }
        return mApplicationModule;
    }}
</code></pre>

<p>moreover, the dependency graph is generally built inside the Application&rsquo;s onCreate method. Given that we want to recreate it with our mocked module, I had to add a method for that:</p>

<pre><code class="java">public class MyApplication extends Application {
    // Stuff 
    @Override
    public void onCreate() {
        super.onCreate();
        initComponent();
    }

    void initComponent() {
        mComponent = DaggerRoboSampleComponent.builder()
                .applicationModule(getApplicationModule())
                .build();
    }
}
</code></pre>

<h2>Conclusion</h2>

<p>The fact that robolectric allows you to use a custom test application object (even a different one for different tests) together with dagger is an easy way to inject mock object without having to rely on ugly setters.</p>

<p>Robolectric is a fast and effective way to speed up your tdd process. All the time spent to set the tests and the mocks app is well repaid in code coverage and writing and debugging speed afterwards.</p>

<h2>See it in action (and have something to copy from)</h2>

<p><a href="https://github.com/fedepaol/RobolectricDependenyInjection">Here on github</a> I put a working example that demonstrates how to inject a mocked module using robolectring.</p>
]]></content>
  </entry>
  
</feed>
