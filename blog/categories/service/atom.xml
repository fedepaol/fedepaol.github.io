<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Service | My little Android warehouse]]></title>
  <link href="http://fedepaol.github.io/blog/categories/service/atom.xml" rel="self"/>
  <link href="http://fedepaol.github.io/"/>
  <updated>2015-09-23T21:40:04+02:00</updated>
  <id>http://fedepaol.github.io/</id>
  <author>
    <name><![CDATA[Federico Paolinelli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tcp Connections in Android]]></title>
    <link href="http://fedepaol.github.io/blog/2012/05/01/tcp-connections-in-android/"/>
    <updated>2012-05-01T00:00:00+02:00</updated>
    <id>http://fedepaol.github.io/blog/2012/05/01/tcp-connections-in-android</id>
    <content type="html"><![CDATA[<div class='post'>
<span style="font-size: large;">Or how to keep your app connected and stop worrying.&nbsp;</span><br /><br /><i>Disclaimer</i>:<br />This is not another place where you can find java code snippet to open a socket and read and write to some server.<br />If you need that, go back to your favorite search engine and look for another result. <u>But be careful</u>: while looking for &#8220;inspiration&#8221; I found a lot of examples where the connection was held inside the UI thread. Please, don&#8217;t do that. At least use an asynctask.<br /><br /><br /><span style="font-size: large;"><i>Short version of this post (spolier warning):</i></span><br /><br /><ul><li>If you need to interact with a tcp server, use a singleton object that contains the socket&nbsp;</li><li>You can access it from all the activities of your app</li><li>If you want to be connected only while in foreground, have a counter that gets incremented on onStart() and gets decremented on onStop() of any client activity. Connect when the counter is &gt; 0, disconnect when the counter is &lt; 0<br /><div><br /></div></li></ul><br /><br /><br /><span style="font-size: large;">Background:</span><br />As a side project, I am developing a simple turn based multiplayer game, with a tcp server as backend (python twisted).<br /><br />In order to make my life easier, I wanted the interaction with the server to work as follows:<br /><br /><br /><ul><li>if the player gets disconnected while playing, it can&#8217;t reconnect and he is out of the current game</li><li>if the app goes background for any reason, it will disconnect from the server</li></ul><div><br /></div><div>The way the app interacts with the server is not the subject of the current post (hint: a thread for sending, one for receiving AND google protobuf for serialization), but it will probably be the subject for some code on github and another blogpost.</div><div><br /></div><div>What I am writing about is <b>how to share a tcp connection between several android activities.</b></div><div><b><br /></b></div><div><br /></div><div><span style="font-size: large;">Using a service to share the socket between android activities:</span></div><div><br /></div><div><ul><li>if you think about something that needs to survive between activities transition, a service is the first&nbsp;thing you think about</li><li>the code to interact with the server was self contained, so in every activity I had to bind to the service, wait for the bind to be done, call the service that called my code</li><li>because of the constraint I imposed to make the tcp server easier, I had to stop the service and restart it whenever my app went background</li><li>I was risking to keep the service around, consuming resources with no reason</li></ul><div>So, use a service ONLY if you really need to keep the connection even if your app is no longer visible.</div></div><div>If you need to do periodical tasks, or if you need to perform one shot operations, please consider using intent services.&nbsp;</div><div>Be kind and let your users know that you are draining their battery, using a notification icon when the service is alive and your app gets backgrounded.</div><div><br /></div><div><span style="font-size: large;">Using a singleton to share the tcp socket:</span></div><div><ul><li>A singleton object resides in your process, and so once started it&#8217;s accessible from all the activities</li><li>You can even run one or more threads inside of it, and they will be running no matter which activity is visible</li><li>Not using a service, you authorize the os to suspend your application (or even to kill it) when it runs out of resources.</li><li>There is no need to have the service layer to bind from the activity, you can access directly your singleton object</li></ul><div>So, this is the BEST WAY to share a tcp connection between activities.</div></div><div><br /></div><div>But what if you want to connect only when the application is foregrounded?</div><div><br /></div><div><span style="font-size: large;">How to check when your application is active:</span></div><div>Have a global counter (a good place might be the singleton itself) that gets incremented every time an onStart() is called from one of your activities, and decremented when onStop() gets called.&nbsp;</div><div><br /></div><div>If that counter is &gt; 0, that means the (at least) one activity is active and then the socket must be connected.</div><div>On the other hand, if the counter gets to 0, no activity is visible and so you need to disconnect.</div><div><br /></div><div>If you are afraid that the counter might go to 0 only because an activity is starting another one and so its onStop() gets called before onStart of the next one, please note that the official android documentation assures us that when starting one activity from another, &nbsp;onStop gets called AFTER onStart() of the started activity <a href="http://developer.android.com/guide/topics/fundamentals/activities.html">http://developer.android.com/guide/topics/fundamentals/activities.html</a>.</div><div><br /></div><div>With that in mind, we are sure that the only time the counter will get to 0 is when the ALL the activities are stopped.</div><div><br /></div><div><br /></div><div>If you liked this post, please consider following me on twitter @fedepaol .</div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Behind Activities: Android, Services, Background Operations and Threads]]></title>
    <link href="http://fedepaol.github.io/blog/2011/04/25/behind-activities-android-services/"/>
    <updated>2011-04-25T00:00:00+02:00</updated>
    <id>http://fedepaol.github.io/blog/2011/04/25/behind-activities-android-services</id>
    <content type="html"><![CDATA[<div class='post'>
This time I want to share something I learned about working in background on android.<br /><br />One of the biggest advantages of android over ios (or, at least, some ios version ago) is that your app is not sandboxed and can continue to live in background.<br /><br />To perform background (not visible) work, all you need to know is how to use android services.<br /><br />A service is a piece of an application that is allowed to be active even if the application is not in foreground anymore. The most commonly used example for describing a service is the music player, which need to continue to play music when your app is hidden by something else.<br /><br />First of all, I want to remark a concept I had some problems with: a service does not have any relationship with threads! The service shares the main (ui) thread with the rest of the components of the app. This means that, if your app is in foreground AND you have a service active AND your service performs some time consuming operations, it will affect the responsivness of the gui (and you don&#8217;t want to disappoint your user).<br />So, even if you are now able to perform some background work, if you expect it to be heavy, please move it inside a thread (or an asynctask) hosted by the service.<br /><br />Another advantage of bringing a service on board is that your application will gain priority over the other apps. Android prefers to kill processes that do not have active services. On the other hand, this means that you should use services carefully if you don&#8217;t want to drain your user&#8217;s battery. If you don&#8217;t need a service anymore, please kill it and restart it later (as pointed out from mark murphy in this old but interesting article: <a href="http://www.androidguys.com/2009/09/09/diamonds-are-forever-services-are-not/">http://www.androidguys.com/2009/09/09/diamonds-are-forever-services-are-not/</a>)<br /><br />Said that, I am now going to list some typical service usage patterns<br /><br /><ul><li><span class="Apple-style-span" style="color: red;">Listen and react to events from outside </span>which need to be handled even if the application is not active (and maybe when the device is idle), such as location variation, accelerometer, incoming calls and so on</li><li><span class="Apple-style-span" style="color: red;">Tasks that need to be performed periodically</span>, like polling a mail server every 15 minutes</li><li><span class="Apple-style-span" style="color: red;">Continuous tasks</span> (like playing a song, or sampling the location with a very narrow interval) that need to be performed in background</li></ul><br /><br />I would say the first two are similar, and the third needs to be handled in a different way.<br /><br /><br /><span class="Apple-style-span" style="font-size: large;"><b>One shot tasks</b></span><br />If you need one shot tasks (like downloading your email), you could:<br /><br /><ol><li>start a service with an <i>intent</i></li><li>return <i>START_NOT_STICKY</i> in its <i>onCommand</i> callback</li><li><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">start an <i>AsyncTask</i> to perform the heavy operations</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">OR</div></li></ol><br /><div style="text-align: center;"><b><span class="Apple-style-span" style="color: red;"><u>you can use an IntentService.&nbsp;</u></span></b></div><div style="text-align: center;"><br /></div>IntentServices are useful as much as they are little advertised.<br />If your service is an intentservice, it will be automatically hosted in its own thread. You can send it as many actions to be performed you want bundled in intents. They will be queued and handled one at a time.<br />You don&#8217;t even have to bother if you need to shut the service down. It will automatically shut down when you return from the <i>onHandleIntent</i> call.&nbsp;Much simple, isn&#8217;t it?<br /><br />Here are some simple scenarios for using intent services:<br /><br /><ul><li><span class="Apple-style-span" style="color: red;">Background operation triggered from user</span> (such as a button):&nbsp;Just pack the command in an intent, and launch the service with the intent.</li><li><span class="Apple-style-span" style="color: red;">React to some broadcast event</span> (such as some system broadcast event):&nbsp;Register a broadcast receiver in your manifest and then launch the intent service from its onReceive. You can&#8217;t handle long running operations in the broadcast receiver, there is a strict time limit in broadcast handling.</li><li><span class="Apple-style-span" style="color: red;">Perform periodic tasks</span>: Use an alarm manager and make it launch your intent service. I also remind you that using setInexactRepeating in this case will help your&nbsp;app to save more resources.</li></ul><br /><br /><b><span class="Apple-style-span" style="font-size: large;">Long running tasks</span></b><br /><br />If you need to need to perform long, continuous background operations, you have no options, and you need a classic service, returning <i>START_STICKY</i> in its <i>onCommand()</i> method.<br />Again, remember that in this case you need to perform time consuming operations inside a thread or an asynctask, because the service shares the same thread with the gui.<br /><br /><br /><br /><a name='more'></a><br /><br /><br />The next time I will try to write down some more practical stuff on how to implement activities and services communication.<br /><br /><br />If I wasn&#8217;t clear enough, if you broke your phone trying to implement this advices, or if you think I&#8217;d better shoot in my foot than writing this ugly stuff in a very poor engRish, drop me an email fedepaol <at> gmail.com .</at><br />If you liked this post, you can consider following me on twitter @fedepaol .<br /><br /><br />UPDATE: I am currently (23/01/2012) working on a library to be used to interact with a service using an intent service. In case you may be interested, you can find it here&nbsp;<a href="https://github.com/fedepaol/PostmanLib--Rings-Twice--Android">PostmanLib - Android webservice interaction</a><br /><br /><div><br /></div></div>

]]></content>
  </entry>
  
</feed>
