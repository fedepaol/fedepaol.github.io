<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Lifecycle | My little Android warehouse]]></title>
  <link href="http://fedepaol.github.io/blog/categories/lifecycle/atom.xml" rel="self"/>
  <link href="http://fedepaol.github.io/"/>
  <updated>2016-09-13T08:57:05+02:00</updated>
  <id>http://fedepaol.github.io/</id>
  <author>
    <name><![CDATA[Federico Paolinelli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Reactive Android Timers, Countdowns and Lifecycle]]></title>
    <link href="http://fedepaol.github.io/blog/2016/06/20/how-to-a-timer/"/>
    <updated>2016-06-20T23:06:59+02:00</updated>
    <id>http://fedepaol.github.io/blog/2016/06/20/how-to-a-timer</id>
    <content type="html"><![CDATA[<h4>Ok, I must confess</h4>

<p>the title is built to draw people&rsquo;s attention, because you know, nowdays everything is done in a reactive fashion. RxJava is superhelpful, but <strong>if we forget the ecosystem our apps are running into</strong>, we risk to forget the <em>proper</em> way to implement certain tasks in Android.</p>

<h4>Why do we need a whole post about timers?</h4>

<p>Recently, I had to implement a countdown timer in Android.</p>

<p>If you google for <del>code to cut and paste</del> <em>inspiration</em>, you&rsquo;ll get a lot of results like:</p>

<ul>
<li>use a <a href="https://developer.android.com/reference/android/os/CountDownTimer.html">countdown timer</a></li>
<li>use a dyi implementation using handlers</li>
<li>be <em>a la mode</em> and use <a href="http://reactivex.io/documentation/operators/timer.html">RxJava&rsquo;s timer</a></li>
</ul>


<p>There is even a <a href="https://androidcookbook.com/Recipe.seam;jsessionid=DF53064E03C7505C4EBF727E56E0728E?recipeId=1205">cookbook recipe</a> that shows how to implement it.</p>

<p>That might work if you had to measure the cooking time of a <a href="http://www.bettycrocker.com/how-to/tipslibrary/charts-timetables-measuring/timetable-cooking-pasta">portion of capellini</a> (the fastest cooking pasta I could think of).</p>

<h3>But wait, what if I had to bake a plum cake?</h3>

<p>Baking a plum cake takes longer than an hour. All the solutions I just mentioned rely on the fact that your application is running <strong>for the whole lenght of the timer</strong>.</p>

<p>This could be acceptable in the desktop / server world, but it&rsquo;s far from acceptable in the Android context: if the app goes in background because the user wants to check his email, answer to a phone call or play a game, <strong>the operating system is likely to reclaim the resources and shutdown the app itself</strong>. In any case, the device will turn off after a short time. If you think that using a <a href="https://developer.android.com/training/scheduling/wakelock.html">wakelock</a> will solve the problem&hellip; it will, but the user won&rsquo;t be happy of all the battery wasted by the screen.</p>

<h3>I can use a foreground service!</h3>

<p>So one can start looking for a way to keep the app running in background. A <a href="https://developer.android.com/guide/components/services.html">Service</a> is an Android component made specifically for this purpose.</p>

<p>By using a Service with the <a href="https://developer.android.com/guide/components/services.html#Foreground">startForeground</a> option, your app will stay alive through the whole lenght of the timer. When the timer is finished, it just has to throw a notification and a broadcast so the user will know that the timer expired.</p>

<p><img class="center" src="/images/soareyoutelling_timer.jpg" width="300"></p>

<p>This approach will work, but it has a drawback. Your app (or let&rsquo;s say at least the service) needs to be running for the whole length of the timer. This is a waste of memory and cpu.</p>

<h3>The right way</h3>

<p>The right way is to take advantage of what the OS offers. The idea here is to run the countdown timer as long as the app is foregrounded, showing the progress to the user <em>one second at the time</em>, but set a system alarm whenever the app goes in background. Whenever the user gets back to the app, you&rsquo;ll cancel the system alarm and restart the timer from where it is supposed to start.</p>

<p>Here what it would look like when the user gets back to the app before the timer is expired (on the left) and when the timer expires while the app is in background (on the right):</p>

<p><img src="/images/timer_resume.png" width="300"> <img src="/images/timer_pause.png" width="300"></p>

<p>From the user&rsquo;s perspective, the timer is running even if the app is in background, because whenever he returns to the app he sees what he is expecting to see (the time passed). On the other hand, if the timer expires when the app is in background, a friendly notification will remind him that he has to take the plum cake out of the oven.</p>

<p>Inside the app however, the timer will run <strong>only when the app is in foreground</strong> and has all the rights to consume cpu because the user is using the app.</p>

<h3>Some code</h3>

<p>A simplified version of what I am describing can be found in my <a href="https://github.com/fedepaol/AndroidTimerSample">github repo</a></p>

<p>There are three things you have to take into account:</p>

<h2>Running the timer in the app</h2>

<p>This is the easiest part: you can use a countdown timer, a handler, rxjava or whatever you want to <del>copy and paste</del> take inspiration from.
In my example I&rsquo;ll use a countdown timer since it&rsquo;s simple to use and serves the purpouse.</p>

<pre><code class="java">    private void startTimer() {
        mCountDownTimer = new CountDownTimer(mTimeToGo * 1000, 1000) {
        public void onTick(long millisUntilFinished) {
        mTimeToGo -= 1000;
        updateTimeUi();
        }
        public void onFinish() {
        mState = TimerState.STOPPED;
        onTimerFinish();
        updateTimeUi();
    }
        }.start();
    }
</code></pre>

<h2>Remembering when the timer was started / how long it was supposed to run</h2>

<p>This is the trickiest part.
In the example I store the starting time inside the shared preferences storage. It will persist even if the app is killed.</p>

<pre><code class="java">    mPreferences.setStartedTime(getNow());
</code></pre>

<p>That value is used when resuming the app in order to check how long the timer has to run (or if the time did expire):</p>

<pre><code class="java">    private void initTimer() {
        long startTime = mPreferences.getStartedTime();
        mTimeToGo = (TIMER_LENGHT - (getNow() - startTime));
        if (mTimeToGo &lt;= 0) { // TIMER EXPIRED
            mTimeToGo = TIMER_LENGHT;
            onTimerFinish();
        } else {
            startTimer();
        }
    }
</code></pre>

<p>The app tries to retrieve the start time value. If there still is  some time to run, the countdown restarts for the remaining length of time. Otherwise the timer is reset and the user is notified of the timer expiration.</p>

<p>Please note that this is a ultra simplified version that assumes that <em>the timer is running</em>. The <a href="https://github.com/fedepaol/AndroidTimerSample">github sample</a> checks also if the timer was started or not.</p>

<h2>Handling the alarm</h2>

<p>This is simple. You should set the alarm that triggers a broadcast receiver through the alarm manager:</p>

<pre><code class="java">    @Override
    protected void onPause() {
        super.onPause();
        long wakeUpTime = (mPreferences.getStartedTime() + TIMER_LENGHT) * 1000;
        AlarmManager am = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
        Intent intent = new Intent(this, TimerExpiredReceiver.class);
        PendingIntent sender = PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT);
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {
            am.setAlarmClock(new AlarmManager.AlarmClockInfo(wakeUpTime, sender), sender);
        } else {
            am.set(AlarmManager.RTC_WAKEUP, wakeUpTime, sender);
        }
    }
</code></pre>

<p>and cancel it in onResume:</p>

<pre><code class="java">    @Override
    protected void onResume() {
        super.onResume();
        Intent intent = new Intent(this, TimerExpiredReceiver.class);
        PendingIntent sender = PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT);
        AlarmManager am = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
        am.cancel(sender);
   }
</code></pre>

<p>Launching a system notification that brings the user back to the app when clicked is trivial. You can check the <a href="https://github.com/fedepaol/AndroidTimerSample">sample on github</a>.</p>

<h2>Conclusion</h2>

<p>What I wrote today may sound obvious to a lot of experienced developers.</p>

<p>However, I thought it was a post worth writing since it&rsquo;s a good example of how you should always remember the ecosystem your app is being run into.
If you forget this and think that <strong>your app is the most important app the user has in his phone</strong>, you&rsquo;ll face some unexpected behaviours (the app gets killed) or you will piss the user off (the app needs to be active for the whole length of the timer).</p>

<p>Thanks as always to Fabio Collini and Riccardo Ciovati for proofreading.</p>
]]></content>
  </entry>
  
</feed>
