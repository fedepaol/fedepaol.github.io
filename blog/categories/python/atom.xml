<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | My little software store]]></title>
  <link href="http://fedepaol.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://fedepaol.github.io/"/>
  <updated>2018-10-26T20:45:18+02:00</updated>
  <id>http://fedepaol.github.io/</id>
  <author>
    <name><![CDATA[Federico Paolinelli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Migrating From Blogger to Octopress (Done!)]]></title>
    <link href="http://fedepaol.github.io/blog/2014/08/24/migrating-from-blogger-to-octopress-done/"/>
    <updated>2014-08-24T19:29:46+02:00</updated>
    <id>http://fedepaol.github.io/blog/2014/08/24/migrating-from-blogger-to-octopress-done</id>
    <content type="html"><![CDATA[<p>It feels a bit like this <img src="http://i.imgur.com/t0XHtgJ.gif" alt="Light bulb" /></p>

<p>but when I had to write a new blogpost and had to embed some code snippets into my blogger hosted blog, I got so pissed of that I chose to migrate my existing blog to a github hosted instance of octopress.</p>

<p>Jason Jarrett made a pretty nice tutorial about the whole process <a href="http://staxmanade.com/2014/04/migrating-blogspot-to-octopress-part-1-introduction/">here</a>.
However, I had to change a couple of things and I thought those might be helpful to anybody who faces the same problems.</p>

<p>The overall process is something like:</p>

<ul>
<li>setup octopress</li>
<li>import an exported dump of blogger</li>
<li>fix internal links</li>
<li>setup redirects from blogger to your new blog</li>
</ul>


<h2>Setting octopress up</h2>

<p>Nothing to say here. Just go to octopress website and follow the instructions.</p>

<h2>Importing posts from blogger</h2>

<p>This is pretty straightforward too. Export your blogger content as xml, and use <a href="https://gist.github.com/juniorz/1564581">this ruby script</a> that generates a <em>posts</em> folder containing all the posts exported from blogger. Anyway, refer to <a href="http://staxmanade.com/2014/04/migrating-blogspot-to-octopress-part-4-import-content-into-ctopress/">Jason&rsquo;s blog</a>, everything is described accurately there.</p>

<h2>Fix internal links</h2>

<p>You&rsquo;ll have to play a bit with <em>sed</em> in order to fix internal links, otherwise they will keep pointing to blogspot.</p>

<h2>Setup redirects</h2>

<p>Here is where things get interesting, because you will want to make visitors of the old url be redirected to the new blog (possibily with 301). The whole process is a bit tricky due to blogger limitation (for more details check <a href="http://staxmanade.com/2014/04/migrating-blogspot-to-octopress-part-6-301-redirect-old-posts-to-new-location/">here</a>).</p>

<p>There are a couple of other obstacles too: the script available is powershell only. Moreover, Jason suggets to use the alias plugin <a href="https://github.com/imathis/octopress/issues/1610">which seems to be broken at the moment</a>.</p>

<p>However, <a href="https://github.com/jekyll/jekyll-redirect-from">jekyll-redirect</a> seems to work fine, so I chose to use it in my solution.</p>

<p>And finally, since powershell is not an option, here is my python version of the script. It binds the post id with the title of the posts, loop all the html files in your post folder, injects the redirection in the yaml header.</p>

<p>Using it is as easy as calling:
<code>sh
python blogger_import.py -p octopress/source/_posts/ -b ./blog-08-22-2014.xml
</code></p>

<p>where p is the path of your posts folder, b is the xml file produced by blogspot.</p>

<p>Here is the script:</p>

<p><div><script src='https://gist.github.com/e46635e3d7de475b0546.js'></script>
<noscript><pre><code>import argparse
import xml.etree.cElementTree as ET
import os


def is_post(node):
    t = node.find(&#39;{http://www.w3.org/2005/Atom}category&#39;).get(&#39;term&#39;)
    d = node.find(&#39;{http://purl.org/atom/app#}control&#39;)
    return (not d) and (t == &#39;http://schemas.google.com/blogger/2008/kind#post&#39;)

def get_posts_id(blogger_dump):
    title_map = {}
    tree = ET.parse(blogger_dump)
    elem = tree.getroot()
    feed = elem.findall(&#39;{http://www.w3.org/2005/Atom}entry&#39;)
    for f in filter(is_post, feed):
        post_id = f.find(&#39;{http://www.w3.org/2005/Atom}id&#39;)
        id_number = post_id.text.split(&#39;-&#39;)[2]
        post_title = f.find(&#39;{http://www.w3.org/2005/Atom}title&#39;).text
        title_map[post_title] = id_number
    return title_map

def inject_redirect(file_name, title_map):
    yaml_separator = 0
    old_file = file_name + &#39;old&#39;
    print file_name
    print old_file
    os.rename(file_name, old_file)
    f = open(old_file, &#39;r&#39;)
    n = open(file_name, &#39;w+&#39;)
    for line in f:
        if line == &#39;---&#39;:
            yaml_separator = yaml_separator + 1
        if yaml_separator == 2:
            n.write(line)
            continue
        if line.startswith(&#39;title&#39;):
            title = line.split(&#39;&quot;&#39;)[1]
            try:
                post_id = title_map[title]
                n.write(&#39;redirect_from:\n&#39;)
                n.write(&#39;  - /blog/%s/\n&#39;%post_id)
            except KeyError:
                print &#39;id not found for &#39; + title
        n.write(line)

def set_redirect(posts_path, titles_map):
    for file_name in os.listdir(posts_path):
        if (file_name.endswith(&#39;html&#39;)):
            inject_redirect(os.path.join(posts_path, file_name), titles_map)

if __name__ == &#39;__main__&#39;:
    parser = argparse.ArgumentParser()
    parser.add_argument(&#39;-p&#39;, &#39;--posts&#39;, dest=&#39;posts_path&#39;, help=&#39;path of the converted _posts&#39;)
    parser.add_argument(&#39;-b&#39;, &#39;--blogger&#39;, dest=&#39;blogger_dump&#39;, help=&#39;blogger dump file&#39;)
    args = parser.parse_args()

    titles_map = get_posts_id(args.blogger_dump)
    set_redirect(args.posts_path, titles_map)
</code></pre></noscript></div>
</p>

<h2>TL;DR</h2>

<ul>
<li>Read <a href="http://staxmanade.com/2014/04/migrating-blogspot-to-octopress-part-1-introduction/">Jason&rsquo;s blog</a></li>
<li>When setting up redirection, install <a href="https://github.com/jekyll/jekyll-redirect-from">jekyll-redirect</a></li>
<li>Use my script to inject redirection in the header of exported blogposts</li>
<li>Setup blogger template as described in Jason&rsquo;s blog</li>
</ul>


<p>PS: I still need to write the blogpost that made me switch to octopress.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Content Providers Generator]]></title>
    <link href="http://fedepaol.github.io/blog/2012/11/11/android-content-providers-generator/"/>
    <updated>2012-11-11T00:00:00+01:00</updated>
    <id>http://fedepaol.github.io/blog/2012/11/11/android-content-providers-generator</id>
    <content type="html"><![CDATA[<div class='post'>
During the refactoring of my two years old app DroidAlone, I decided to try to access to the storage through a ContentProvider.<br /><br />Even if the official documentation warns that there is no need to use content providers if your app does not want to export it&#8217;s data against other apps, there are a bunch of advantages in using a content provider in your app.<br /><br />The main and more obvious advantage is that you can use a Loader with your data. Using loaders relieve you from managing the cursor, forgetting open cursors here and there and most of all, makes a lot easier for your ui to react to changes in your model. Well, more than easier, you don&#8217;t have to do anything.<br /><br />However, I am not writing this post to describe how to interact with an android content provider, nor how to implement a content provider. There are a lot of content provider tutorials out there that probably can explain how them work better than I could possibly ever do (and in a better English).<br /><br />I am writing this post because while writing the content provider, I got bored.<br />It&#8217;s a lot of code, always the same, that cannot be avoided, and you don&#8217;t have to add any value to it. The best thing you can do is not getting distracted and write it with no errors. And it&#8217;s loong (ok, not that long).<br /><br />Given the &#8220;boilerplateness&#8221; of this problem, I thought I could take off some dust from my old <a href="http://fedepaol.github.io/blog/2010/11/18/my-sqllite-helper-builder">SqliteHelper builder script</a>&nbsp;and maybe make it able to generate the content provider class for me. And that&#8217;s what I did.<br /><br /><h3>Android Content Provider Generator</h3><br /><a href="https://github.com/fedepaol/Android-sql-lite-helper">https://github.com/fedepaol/Android-sql-lite-helper</a><br /><br />I added a couple of options to it, and now it can generate automatically for you (no more cut/paste, no more forgotten columns) the content provider class AND a client class with a bunch of methods you can use to add / update / delete / query your data.<br />A sample of the generated code is already included in the beta of my app and it seems to work properly.<br /><br />I won&#8217;t write any instructions or examples here, they are already in the github repo.<br /><b>All you need to know is that with a 10 rows text file that describes your data, you can generate the whole content provider</b>.<br /><br />As <a href="https://plus.google.com/105096943850026101634/posts/RTbp2zVPZQq">I wrote on G+</a>, it&#8217;s certainly not the most elegant piece of python I wrote, but it makes it&#8217;s job.<br /><br /><br /><br />If you liked this post (or my script), consider following me on twitter @fedepaol<br /><br /></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My Sqllite Helper Builder]]></title>
    <link href="http://fedepaol.github.io/blog/2010/11/18/my-sqllite-helper-builder/"/>
    <updated>2010-11-18T00:00:00+01:00</updated>
    <id>http://fedepaol.github.io/blog/2010/11/18/my-sqllite-helper-builder</id>
    <content type="html"><![CDATA[<div class='post'>
EDIT 11/11/2012: as described in <a href="http://fedepaol.github.io/blog/2012/11/11/android-content-providers-generator">this new blog post</a>, I modified the script to generate a content provider as well<br /><br />This is my first post about something related to android.<br />Just to break the ice, I would like to introduce a simple helper script I developed this summer.<br /><br />Android ships with a very nice local storage, which is sqllite. It&#8217;s said almost everywhere that, in order to make your life easier, you should develop an helper class.<br />It will take care of open / close the sqllite db, of the version control and of any other kind of interaction you may have with it.<br /><br />A nice example can be found in the official android documentation <a href="http://developer.android.com/guide/topics/data/data-storage.html#db">here</a><br />or <a href="http://developer.android.com/resources/samples/NotePad/index.html">here</a>.<br />Reto Meier in his excellent &#8220;Professional Android Development&#8221; explains the same, and I am pretty sure its the same for other manuals.<br /><br />Well, building a sqllite helper is BOOORING. You always have to do the same things, write the same functions of every table you want to store in it.<br />And here is where my script comes in your help.<br />You just provide it a configuration file with the description of the tables you want to store in it, and it will give you the dbhelper java file.<br /><br /><br />A configuration file looks like this:<br /><br /><pre style="background-color: #eeeeee; border: 1px dashed rgb(153, 153, 153); color: black; font-family: Andale Mono,Lucida Console,Monaco,fixed,monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code><br />CLASS Employee<br />String Name<br />Date Birthday<br />Double weigth<br />ENDCLASS<br /><br />CLASS Call<br />String Number<br />Date Time<br />ENDCLASS</code></pre><br /><br />The available types are<br />String, Double, Long, Integer and Date<br /><br />The available script commands are:<br /><br /><pre style="background-color: #eeeeee; border: 1px dashed rgb(153, 153, 153); color: black; font-family: Andale Mono,Lucida Console,Monaco,fixed,monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code> -h, --help            show this help message and exit<br />-i INFILE, --infile=INFILE<br />                     file that contains classes definition<br />-n NAME, --name=NAME  name of the dbhelper class<br />-p PACKAGE, --package=PACKAGE<br />                     name of the package</code></pre><br /><br /><br /><br />So, instead of spending an entire afternoon writing the same add / remove / getAll methods, all you have to do is to compile the configuration file, launch something like<br /><br /><pre style="background-color: #eeeeee; border: 1px dashed rgb(153, 153, 153); color: black; font-family: Andale Mono,Lucida Console,Monaco,fixed,monospace; font-size: 12px; line-height: 14px; overflow: auto; padding: 5px; width: 100%;"><code>python sql_lite_helper.py -i sample.txt -n MyDbAdapter -p com.my.package</code></pre><br /><br />and you&#8217;ll have your brand new sqllite helper class. Of course you can extend it, for example if you want to have some insert / get methods that accept and return java classes instead of fields, but in any case it will save you a lot of time.<br /><br />An example of the output file can be found <a href="http://dl.dropbox.com/u/3092639/Archive.zip">here</a>.<br /><br />The script is available on github <a href="https://github.com/fedepaol/Android-sql-lite-helper">here</a>.<br /><br />I really hope it can help somebody. If you have any issues / requests, feel free to contact me at fedepaol[AT]gmail[DOT]com .</div>

]]></content>
  </entry>
  
</feed>
