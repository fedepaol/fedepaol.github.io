<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Talks | My little software store]]></title>
  <link href="http://fedepaol.github.io/blog/categories/talks/atom.xml" rel="self"/>
  <link href="http://fedepaol.github.io/"/>
  <updated>2018-12-11T23:09:55+01:00</updated>
  <id>http://fedepaol.github.io/</id>
  <author>
    <name><![CDATA[Federico Paolinelli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fast Messaging With Nats and Go Part 2]]></title>
    <link href="http://fedepaol.github.io/blog/2018/12/11/fast-messaging-with-nats-and-go-part-2/"/>
    <updated>2018-12-11T22:32:15+01:00</updated>
    <id>http://fedepaol.github.io/blog/2018/12/11/fast-messaging-with-nats-and-go-part-2</id>
    <content type="html"><![CDATA[<p>This is the second of a follow up serie of the talk <em>Fast messaging with Nats and Go</em> I gave at <a href="golab.io">golab 2018</a>.
The first part can be found <a href="http://fedepaol.github.io/blog/2018/10/27/fast-messaging-with-nats-and-go/">here</a></p>

<h2>What can we do with nats?</h2>

<h3>Pub sub</h3>

<p>As you can probably guess, given that Nats is a pure pub / sub system, we can easily implement pub / sub.</p>

<p><img src="/images/nats/pubsub.png" width="350"></p>

<p>Please remember that a nats publisher does not assume the audience. The published message can reach one, 1000 or 0 subscriber. If no subscribers are connected the message is gone forever.</p>

<h3>Queueing</h3>

<p>Queueing is a variant of pub / sub where the subscriber announces itself to belong to a subscription group. In that case the Nats server will send randomly the subscribed message <strong>only to one subscriber</strong>.</p>

<p><img src="/images/nats/queueing.png" width="450"></p>

<p>This is useful in case you want to implement a load balancing policy. On top of that is really easy to scale up (or down) by adding new subscribers to the subscription group.</p>

<h3>Request / Reply</h3>

<p>Request / Reply is <strong>just syntactic sugar</strong> over the pub / sub mechanism provided by Nats: the publisher sends a reply subject together with the message and expects any reply to be sent to that reply subject.</p>

<p>The subscribers receive the request message together with the reply subject and sends the reply to that subject.</p>

<p><img src="/images/nats/reqreply.png" width="450"></p>

<p>Given the nature of Nats, the request gets received to all the registered subscribers. The requestor just handles the first reply it receives and discards all the other replies.</p>

<p>Apart from this (quite) not efficient way to handle req / reply, this mechanism can be used together with queueing we just discussed making only one receiver of the subscription group receive the request.</p>

<h2>Using Nats with Go</h2>

<p>First of all, there are clients for a lot of languages already available, from the most fancy ones (rust or elixir) to some out of fashiones (even perl!).</p>

<p>The go client does a bit more than just implementing the text based protocol. In particular:</p>

<h4>Handles the connection / reconnection gracefully</h4>

<p>Given that a client connected to the cluster gets notified of all the nodes of the cluster via the gossiping mechanism, whenever a client detects a disconnection from a node, it tries to reconnect to one of the other nodes of the cluster.</p>

<p>While the reconnection is in progress, any messages that we would like to send are buffered up to a configurable limit (the default is something like 8 Mb).</p>

<h4>Tries to avoid slow client errors by emptying the socket</h4>

<p>The client tries to receive all the available messages and pass them to the application. To do that, it buffers the messages received in order to avoid to be marked as a <em>slow client</em> by the server. When the receive buffer is full, it tries to notify the client of the library by raising errors.</p>

<h3>Some code</h3>

<pre><code class="go">    nc, _ := nats.Connect(nats.DefaultURL)

    nc.Publish("foo", []byte("Hello World"))
    nc.Subscribe("foo", func(m *nats.Msg) {
        // handle the message
    })
    nc.Flush()

    // chan subscribe
    ch := make(chan *nats.Msg, 64)
    sub, err := nc.ChanSubscribe("foo", ch)
    msg := &lt;- ch
</code></pre>

<p>Sending and receiving takes just a few lines of code. There is also a channel based subscription where the received messages are sent through a channel.
Beware that sending are asynchronous operations, <code>nc.Flush()</code> is needed in order to force the client to send the messages out.</p>

<p>Using request / reply is just as straightforward:</p>

<pre><code class="go">    // Requests    
    var response string
    err := c.Request("help", "help me", &amp;response, 10*time.Millisecond)
    if err != nil {
            fmt.Printf("Request failed: %v\n", err)
    }

    // Replying
    c.Subscribe("help", func(subj, reply string, msg string) {
            c.Publish(reply, "I can help!")
    })
    // Queue group reply
    nc.QueueSubscribe("help", "workers", func(msg *Msg) {
          c.Publish(msg.Reply, "I can help!")
    })
</code></pre>

<p>Request / reply are blocking (whereas pub / sub are asynchronous) and as we already mentioned can be used together with subscription groups.</p>

<p>The request accepts a <code>timeout</code> parameter but there is also a variant that accepts a <code>context</code> in order to let the caller be able to interrupt the request.</p>

<h3>The go client does a lot more</h3>

<ul>
<li>it provides connection lifecycle callbacks (if you want to override the reconnection mechanism)</li>
<li>it provides asynchronous and synchronous versions of the apis</li>
<li>it provides encoders (json and protobuf) in order to use type safe callbacks</li>
</ul>


<p>This (and a lot more) can be found on the official nats go client <a href="https://github.com/nats-io/go-nats">here</a>.</p>

<p>I hope I triggered your curiosity in trying a powerful (yet simple) messaging system.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fast Messaging With Nats and Go]]></title>
    <link href="http://fedepaol.github.io/blog/2018/10/27/fast-messaging-with-nats-and-go/"/>
    <updated>2018-10-27T21:48:29+02:00</updated>
    <id>http://fedepaol.github.io/blog/2018/10/27/fast-messaging-with-nats-and-go</id>
    <content type="html"><![CDATA[<p>This is the first of follow up serie of the talk <em>Fast messaging with Nats and Go</em> I gave at <a href="golab.io">golab 2018</a>.</p>

<h3>The slides of the talk can be found here:</h3>

<script async class="speakerdeck-embed" data-id="001030954dc6483285e47ccf4906a7d0" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>


<h3>What is Nats</h3>

<p><a href="nats.io">Nats</a> is a messaging system hosted under the <a href="www.cncf.io">CNCF</a> umbrella, which is an <em>open source software foundation dedicated to making cloud native computing universal and sustainable</em>. It&rsquo;s my place-to-go while looking for software related to distributed systems. I am just a user of Nats reporting my experience and my understanding of how it works. What follows might be inaccurate or wrong :-)</p>

<h3>Why messaging</h3>

<p>The way we architect and build our applications changed in the past few years, moving from monolithic apps to distributed and therefore interacting (micro) services. Together with that, some communication patterns emerged.</p>

<p>Even if the most popular one is to use rest and there are popular libraries for synchronous interaction such as <a href="https://grpc.io/">grpc</a> or <a href="https://thrift.apache.org/">thrift</a>, some interactions are better represented using events and messaging.</p>

<h3>Good points of messaging</h3>

<p>Messaging is a natural way to decouple producers of messages from consumers of those messages. The producer does not know who (if any) is going to consume the message, the consumer does not know where that message is coming from.</p>

<p><strong>This makes scalability easier:</strong> you can throw in / remove producers (or consumers) and your application will scale accordingly without having to change anything.</p>

<p>Messaging <strong>enables different kinds of interaction</strong>, for example <a href="https://martinfowler.com/eaaDev/EventSourcing.html">event sourcing</a>, where the state of a service is emitted as a sequence of updates which are collected in order to reconstruct the current state in another service.</p>

<p>Messaging makes it easier to implement all the kinds of <em>reactive</em> paradigms, where the evolution of our system is driven by the emission and the reaction to messages sent and received by our services.</p>

<h3>There are a lot of messaging systems, what do I need to look for in one of them?</h3>

<p>Some aspects that we need to take in consideration are:</p>

<p><strong>Messaging patterns:</strong> Does the messaging system support pub/sub? Request/reply? Fan-in? Any other kind of exotic messaging pattern?</p>

<p><strong>Durability of the messages:</strong> How long will the messages last? Will be there forever(ish)? Will they expire after a short timeout? Will they be thrown away if they are not consumed immediately?</p>

<p><strong>Ordering guarantees:</strong> Will the messages be always received in the same order the publisher is publishing them?</p>

<p><strong>Routing capabilities:</strong> How does the system route the messages? Is it topic based? Does it support wildcarding?</p>

<p><strong>Dev / Ops experience:</strong> This is often underestimated: how easy it is to interact with the system? How much boilerplate code is required? And also, how easy is to configure and to maintain the system? Does it require a lot of knobs to be turned in order to configure it properly?</p>

<p><strong>Performance:</strong> Is it fast? How does it behaves under load?</p>

<p><strong>Auth / Authz:</strong> Does it support authentication / authorization? How?</p>

<h3>What makes a good communication system?</h3>

<p>The two extremes of the spectrum are</p>

<h4>The Enterprise Service Bus:</h4>

<p>Popular during the SOA movement, the bus held a lot of logic itself. Transformation, routing rules, manipulation and filtering of the messages. The result was that the logic was split between the endpoints and the bus itself, making really difficult to understand the big picture.</p>

<h4>What Martin Fowler says:</h4>

<p>In <a href="https://martinfowler.com/articles/microservices.html">his really popular article about microservices</a>: <em>&ldquo;The microservice community favours an alternative approach: smart endpoints and dumb pipes&rdquo;</em>.</p>

<p><strong>Nats is on the dumb side</strong>, but it&rsquo;s just dumb enough to be useful.</p>

<h2>The protocol</h2>

<p>The nats protocol is text based, which means that you can even telnet them to a Nats server. The messages are delimited by CR - LF .</p>

<p>The main messages are:</p>

<table>
    <tr>
        <td>PUB    -</td>
        <td>Publish a message to a subject, with optional reply subject</td>
    </tr>
    <tr>
        <td>SUB   -</td>
        <td>Subscribe to a subject</td>
    </tr>
    <tr>
        <td>MSG   -</td>
        <td>Delivers a message payload to a subscriber</td>
    </tr>
    <tr>
        <td>UNSUB  - </td>
        <td>Unsubscribe from a subject</td>
    </tr>
</table>


<p></p>

<p>There are also other messages used to establish and keep the connection up, such as <em>CONNECT</em>, <em>PING</em>, <em>INFO</em> .</p>

<h4>The protocol supports wildcards</h4>

<p>Nats subjects support wildcards. The subject are tokens separated by a dot, such as <strong>foo.bar</strong> or <strong>foo.bar.baz</strong>.</p>

<p>There are two types of wildcards: by using <strong>*</strong> a wildcard matches the token (foo.* matches foo.bar but not foo.bar.baz). If you want to match any foo.something you need to use <strong>></strong> (as in <strong>foo.></strong>).</p>

<h2>The server (or, the ops point of view)</h2>

<p>The nats server is a (small) single Go executable. In order to run it, you just start it with</p>

<pre><code>gnatsd -p 4222
</code></pre>

<p>and you are done.</p>

<h4>Autodiscovery</h4>

<p>The nats server provides also a gossip based autodiscovery mechanism. By using it, you can seamlessly add and remove new nodes to the cluster to scale up / down. A new server addition is propagated to all its peers and to all the clients.</p>

<p>The auto discovery is enabled by setting one or more servers as <em>seed server</em> and by pointing them from the peers:</p>

<pre><code>gnatsd -p 4222 -cluster nats://localhost:4248
gnatsd -p 5222 -routes nats://localhost:4248
</code></pre>

<h4>All the servers form a full mesh:</h4>

<p><img src="/images/nats/fullmesh.png" width="450"></p>

<p>Each server is connected to each other, meaning that two clients will always be one hop distant <strong>at most</strong>. Once a client subscribes a subject, its interest will be propagated through all the servers of the mesh.</p>

<h2>Delivery guarantees</h2>

<p>Nats provides very few guarantees:</p>

<ul>
<li><p>It guarantees ordering of messages.</p></li>
<li><p>It&rsquo;s an <strong>at most once delivery</strong> system, which means that if the client is not connected while the message is being published, it won&rsquo;t receive that message. Ever. <strong>The message is not kept on the server</strong>, if a client looses it for some reason and wants it, some kind of recovery mechanism must be implemented (more on this later).</p></li>
</ul>


<p>It&rsquo;s kind of like the tree falling in the forest while nobody is hearing.</p>

<h2>Availability</h2>

<p>The <em>at most once delivery guarantee</em> allows Nats to be <strong>fast and reliable</strong>. (Almost) no state is kept on the server.
<strong>A slow client</strong> is a client that is not able to consume the messages the server is sending to it for more than 1 second (the timeout is configurable).</p>

<p><strong>The nats server behaves in a very selfish manner cutting the connection of the slow clients</strong>, and not having to do the extra work of trying to help slow clients it achieves high levels of consistency and availability,</p>

<h2>That&rsquo;s it for now</h2>

<p>I&rsquo;ll publish the second part soon, where I&rsquo;ll continue continue analyzing Nats following the outline of the talk.</p>
]]></content>
  </entry>
  
</feed>
