<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Robolectric | My little Android warehouse]]></title>
  <link href="http://fedepaol.github.io/blog/categories/robolectric/atom.xml" rel="self"/>
  <link href="http://fedepaol.github.io/"/>
  <updated>2015-09-19T10:39:00+02:00</updated>
  <id>http://fedepaol.github.io/</id>
  <author>
    <name><![CDATA[Federico Paolinelli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mocking With Robolectric and Dagger 2]]></title>
    <link href="http://fedepaol.github.io/blog/2015/09/05/mocking-with-robolectric-and-dagger-2/"/>
    <updated>2015-09-05T08:22:47+02:00</updated>
    <id>http://fedepaol.github.io/blog/2015/09/05/mocking-with-robolectric-and-dagger-2</id>
    <content type="html"><![CDATA[<h2>Why robolectric</h2>

<p>I&rsquo;ve been a fan of robolectric since the old days, since <a href="http://fedepaol.github.io/blog/2012/07/23/intellij-robolectric-and-android/">when Android Studio was not an option and few developers embraced IntelliJ</a>. I left it a bit behind after the introduction of Android Studio, since its support was far from optimal.</p>

<p>Things have changed, and after listening Corey Latislaw advocating its usage during <a href="http://fragmentedpodcast.com/episodes/13/">this fragmented podcast episode</a> I wanted to give it a spin. Even if there is a bit of debate over its usage, mainly because tests are performed against mocked objects instead of the real framework code, it is the fastest lane to your tdd cycle because tests are run on the local jvm instead of being packed in an apk, deployed on a device and run over there.</p>

<h2>Dependency Injection</h2>

<p>One really cool thing about robolectric 3.0 is the fact that you can override the Application object declared in your manifest with a custom one (which can inherit from your application&rsquo;s one).</p>

<p>If you are using dagger (or dagger 2) and you are using the application as the source of dependency injection for your classes, this allow to easily replace your injected objects with mocks. You can even choose which mocks inject in the setup phase of your tests.</p>

<h2>Let&rsquo;s see an example:</h2>

<p>Let&rsquo;s say you have your application class that exposes all the injected objects in a Dagger 2 fashion, and that you are using it to inject classes in your activities:</p>

<pre><code class="java">    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // stuff 
        ((MyApplication) getApplication()).getComponent().inject(this);
    }
</code></pre>

<p>Now, if we can drive the component injected within our tests, the rest of the app would use them and (hopefully) behave in a way we expect, depending on our mocks instead of the real objects.</p>

<p>The dependencies are provided by a module:</p>

<pre><code class="java">@Module
public class ApplicationModule {
    // stuff

    @Provides
    @Singleton
    GitHubClient provideClient() {
        return new GitHubClient(mApp.getApplicationContext());
    }
    // .. Provides other stuff
}
</code></pre>

<p><code>GitHubClient</code> is a Retrofit (2) powered client that helps to retrieve all the repos for a given user.</p>

<p>By using a test only application, we can provide a module from our tests.</p>

<p>Let&rsquo;s see ApplicationModule&rsquo;s mocked alter ego. Note that we can override only the dependencies that we want to mock:</p>

<pre><code class="java">public class MockApplicationModule extends ApplicationModule {
    List&lt;Repo&gt; result;
    // stuff

    @Override
    GitHubClient provideClient() {
        GitHubClient client = mock(GitHubClient.class);
        // mock behaviour
        return client;
    }

    public void setResult(List&lt;Repo&gt; result) {
        this.result = result;
    }
}
</code></pre>

<p>Now that everything is in place, we can use the mocked objects in our tests:</p>

<pre><code class="java">@RunWith(RobolectricGradleTestRunner.class)
@Config(constants = BuildConfig.class,
        application = TestApplication.class)
public class SampleTest {
    @Before
    public void setup() {
        TestApplication app = (TestApplication) RuntimeEnvironment.application;
        // Setting up the mock module
        MockApplicationModule module = new MockApplicationModule(app);
        module.setResult(mockedResult);
        app.setApplicationModule(module);
    }
}
</code></pre>

<p>From now on, the our tested activities will be injected with our mocked github client and we will be able to test their behaviour.</p>

<h2>Quirks</h2>

<p>Since the Test Application object is created before running the tests, a default application module must be provided, otherwise you&rsquo;ll get a dreaded NPE while running your tests.</p>

<pre><code class="java">public class TestApplication extends MyApplication {
    @Override
    ApplicationModule getApplicationModule() {
        if (mApplicationModule == null) {
            return super.getApplicationModule();
        }
        return mApplicationModule;
    }}
</code></pre>

<p>moreover, the dependency graph is generally built inside the Application&rsquo;s onCreate method. Given that we want to recreate it with our mocked module, I had to add a method for that:</p>

<pre><code class="java">public class MyApplication extends Application {
    // Stuff 
    @Override
    public void onCreate() {
        super.onCreate();
        initComponent();
    }

    void initComponent() {
        mComponent = DaggerRoboSampleComponent.builder()
                .applicationModule(getApplicationModule())
                .build();
    }
}
</code></pre>

<h2>Conclusion</h2>

<p>The fact that robolectric allows you to use a custom test application object (even a different one for different tests) together with dagger is an easy way to inject mock object without having to rely on ugly setters.</p>

<p>Robolectric is a fast and effective way to speed up your tdd process. All the time spent to set the tests and the mocks app is well repaid in code coverage and writing and debugging speed afterwards.</p>

<h2>See it in action (and have something to copy from)</h2>

<p><a href="https://github.com/fedepaol/RobolectricDependenyInjection">Here on github</a> I put a working example that demonstrates how to inject a mocked module using robolectring.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intellij, Robolectric and Android]]></title>
    <link href="http://fedepaol.github.io/blog/2012/07/23/intellij-robolectric-and-android/"/>
    <updated>2012-07-23T00:00:00+02:00</updated>
    <id>http://fedepaol.github.io/blog/2012/07/23/intellij-robolectric-and-android</id>
    <content type="html"><![CDATA[<div class='post'>
<br /><br />I have been curious about intellij since droicon uk 2011, where I noticed that some of the speakers were using IntelliJ instead of eclipse.<br /><br />A <a href="https://plus.google.com/115995639636688350464/posts/CgPZkFGvbm3">post</a> from Richard Hyndman, who is a developer advocate from Google, was the final straw that pushed me to download IntelliJ and give it a try.<br /><br />The first thing an eclipse user will notice in intellij is how slick and fast compares to the behemoth which is eclipse. On the other hand, an you can feel a bit disoriented at first.<br /><br /><br />Setting up a new android project using IntelliJ is pretty straightforward. You can follow the nice tutorial from jetbrains website http://wiki.jetbrains.net/intellij/Android.<br />For this reason, I will not write about how to set up an Android project in intellij here.<br /><br /><br />What I am going to write about is how to setup an <b>android project with intellij and integrate robolectric</b> with it.<br /><br />I really like robolectric. It makes unit testing for android a lot faster as it would be on the emulator. What&#8217;s more, you can use mockito with it.<br />Mockito is a mocking framework that makes a lot easier to mock your java objects.<br />Mockito does not work with dalvik jvm, but robolectric makes your tests run on your pc&#8217;s jvm.<br /><br /><br />Despite robolectric provides instruction on how to setup an intellij project manually, I have tried that process a lot of times, carefully checking if I was missing a step.<br />However, I did not manage to get it working. The guys from Pivotal provide also an intellij starter project, which you can configure to point a git repository https://github.com/pivotal/AndroidIntelliJStarter<br /><br /><br />However, I was not either satisfied with this solution and, inspired by this <a href="https://groups.google.com/forum/?fromgroups#!topic/robolectric/QN6dskFjrHc">post</a>&nbsp;,&nbsp;I tried to setup a maven solution and to import it in intellij afterwards.<br /><br />This provides another great benefit, which is the fact that I can import the same project in my linux netbook without bothering for relative paths in eclipse projects.<br /><br />So, here are the steps I had to follow in order to get it working:<br /><br />- Install the android sdk. This is trivial, I assume you are comfortable with that<br />- Let the ANDROID_HOME environment variable point the path where you uncompressed the android sdk<br />- You need to have at least one version of the sdk installed, so if you haven&#8217;t yet, you should launch the sdk manager that is the &#8220;android&#8221; executable on ANDROID_HOME/tools/android. Install also the extras, such as the compatibility library, admob stuff and all the libraries you find at the bottom<br /><br /><br />- install the maven android sdk deployer you can find at <a href="https://github.com/mosabua/maven-android-sdk-deployer">https://github.com/mosabua/maven-android-sdk-deployer </a>and then install it.<br /><br />I read somewhere that you can get android jar without relying on it, but in any case, if you need google maps or other private apis like that you still need to use this tool.<br />&nbsp;I use the latest (almost) version which is 4.0.3, so I run mvn install -P 4.0.3<br /><br /><br />- Install maven android plugin. The easiest way is to use android archetypes from here:<br />https://github.com/akquinet/android-archetypes<br /><br /><br />Finally, you are now ready to generate your first maven android project:<br /><br /><br /><br /><br /><br />mvn archetype:generate \<br />&nbsp; -DarchetypeArtifactId=android-quickstart \<br />&nbsp; -DarchetypeGroupId=de.akquinet.android.archetypes \<br />&nbsp; -DarchetypeVersion=1.0.8 \<br />&nbsp; -DgroupId=your.company \<br />&nbsp; -DartifactId=my-android-application<br /><br /><br /><br />You <i>could</i> find an issue. &nbsp;Recently the tree of the android sdk folders has been slightly changed. Maven android plugin expects them to be in the updated version (I don&#8217;t remember what the differences where). However, if maven complains it cannot find android related stuff, and your sdk has been installed for some time, a good option would be to remove the sdk and reinstall it from scratch (at least the part you download with the sdk manager).<br /><br /><br /><br />At this point, you have a working maven project, which you could already open with intellij. What is still missing is the robolectric dependencies.<br />Nothing more easy, all you have to do is to add<br /><br /><br /><br /><br /><script src="https://gist.github.com/3165830.js?file=aaa.xml"></script> right below android dependencies.  You should also create the test folder, under <i>src/test/your/package/ </i><br /><br />Now, a problem I had was that I had to change the pointer of the repository in order to have robolectric 1.2 working.<br /><div><br /></div><div><br /></div><div><br /></div><br /><script src="https://gist.github.com/3165854.js?file=bbb.xml"></script><br /><br /><br /><br /><br />At this point, you should be able to open the pom.xml with intellij.<br /><br /><br />Now, to have robolectric working from intellij, you still need to make a couple of changes:<br />- the order of include of jars does not respect the one you specified. What&#8217;s more, you will likely to get the STUB! error because android jar is included before junit and robolectric.<br />All you need to do is to move the android jar below junit and robolectric<br /><br />- you need to manually specify the javadocs for android. You do this by highlighting android jar, pressing the little edit in the lower left corner.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-Cix5eHOX7ik/UA2uDjBWp2I/AAAAAAAAHso/ctXgbFyx8Tg/s1600/intellij1.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="200" src="http://3.bp.blogspot.com/-Cix5eHOX7ik/UA2uDjBWp2I/AAAAAAAAHso/ctXgbFyx8Tg/s320/intellij1.png" width="320" /></a></div><br /><br /><br />and pressing the plus sign. Then you choose &#8220;Attach files or directories&#8221;, point the path related to your android docs,<br />which is /docs/references under your ANDROID_HOME. Finally, you declare that it&#8217;s related to javadoc.<br /><br /><br /><br /><br />Now you are _almost_ ready to start. You made all this mess because you want to have robolectric working with intellij.<br /><br />You need to create, right under src/ folder, the following path:<br /><i>src/test/java/ YOUR_PACKAGE&nbsp;</i><br /><i><br /></i><br />where you are going to include your unit tests, and you are done!<br /><br /><br />If you liked this post, please consider following me @fedepaol .<br /><br /><br /><br /><br /><div><br /></div><br /><div><br /></div></div>


<h2>Comments</h2>


<div class='comments'>
<div class='comment'>
<div class='author'>Federico Paolinelli</div>
<div class='content'>
I added here https://dl.dropbox.com/u/3092639/pom.xml a working pom.xml I am currently using. I just tried to mvn clean install from a clean checkout and it looks to be finding robolectric. I hope you are missing something which you can correct using this example. Ping me if you can&#39;t</div>
</div>
<div class='comment'>
<div class='author'>Christopher Perry</div>
<div class='content'>
I added the sonatype repository stuff, and it&#39;s not finding robolectric. Not sure why.</div>
</div>
<div class='comment'>
<div class='author'>Christopher Perry</div>
<div class='content'>
This comment has been removed by the author.</div>
</div>
</div>

]]></content>
  </entry>
  
</feed>
